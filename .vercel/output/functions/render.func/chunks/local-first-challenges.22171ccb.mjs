const id = "local-first-challenges.md";
						const collection = "blog";
						const slug = "local-first-challenges";
						const body = "\nRecently I've been getting excited about [local-first](https://www.inkandswitch.com/local-first/) applications so I thought I would try my hand at building one.\nThe app will be a personal songwriting tool for organizing, versioning, and making notes on in-progress songs. Sort of a personal Soundcloud app of sorts.\nI think I've finally settled on a decent architecture, but the process has forced me to rethink some of my go-to patterns that I use to build on cloud-based software.\n\n## Am I the Client or the Server?\n\nIn my normal day-to-day work I'm almost always writing code for the _client_.\nYou want data? Make an HTTP request from the _server_ to get it.\nYou need a file? Make an HTTP request from the _server_.\nIn a local-first app those boundaries aren't as clear.\nI can write a SQL query right next to my React component!\n\n```tsx\nfunction SomeComponent({ db, id }) {\n\n  async function updateName(name) {\n    await db.execute(`\n      UPDATE songs\n      SET name = ?\n      WHERE id = ?\n    `,\n    [name, id]\n  }\n\n  return (\n    <input\n      onChange={evt => updateName(evt.target.value)}\n    />\n  );\n}\n```\n\n## Storage? Also Syncing. And undo/redo. Oh also searching?\n\nSo far I've found it challenging to get all of these features out of the box.\nLike anything in software, the architecture needs to be based on the needs of the application.\nOne of the best parts about local-first apps is that your data is truly local.\nBut that also means that if you _want_ that data to be available elsewhere (like on a phone perhaps), then you have to figure out how to sync the data.\nAdditionally, if you want multiple people to interact with that data you need to think about merging and conflict resolution.\nTying in undo/redo into syncing and conflict resolution makes all of that a _hard_ application to build.\n\nThe rage right now for local-first apps is [CRDTs](https://crdt.tech/).\nI'm still wrapping my head around it, but I understand enough to know that I don't want to build this myself.\nThere are a couple of libraries out there that do this like [Automerge](https://automerge.org/) and [Y.js](https://yjs.dev/).\nY.js in particular seems pretty darn good as it has syncing and undo/redo out of the box.\n\nThe last challenge that relates here is searching.\nFor a local-first app, it feels strange to _not_ choose SQLite since it can easily and efficiently search and query.\nUsing a CRDT library feels like it forces data into a document-based storage format which conflicts a little with how one might typically structure a SQLite database.\n\nCan you have a CRDT data structure that supports undo/redo and store that in SQLite?\nProbably, but I haven't figured it out yet.\n";
						const data = {title:"Challenges of a Local-first App",date:new Date(1657929600000),description:"Blurring the lines of client and server"};
						const _internal = {
							type: 'content',
							filePath: "/Users/nickball/code/npb/src/content/blog/local-first-challenges.md",
							rawData: "\ntitle: Challenges of a Local-first App\ndate: 2022-07-16\ndescription: Blurring the lines of client and server",
						};

export { _internal, body, collection, data, id, slug };
