import { j as createVNode, F as Fragment, k as spreadAttributes } from './astro.c61b1d12.mjs';
import 'cookie';
import 'kleur/colors';
import 'path-to-regexp';
import 'mime';
import 'string-width';
import 'html-escaper';

const images = {
					
				};

				function updateImageReferences(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="([^"]+)"/gm,
						(full, imagePath) => spreadAttributes({src: images[imagePath].src, ...images[imagePath].attributes})
					);
				}

				const html = updateImageReferences("<p>If you‚Äôre building a web app that allows users to write free-form text in 2018,\nit‚Äôs very likely that you‚Äôll come upon the need to present that text with\nvarious formatting options like <strong>bold</strong> or <em>italic</em>, so called <a href=\"https://techterms.com/definition/richtext\"><em>rich text</em></a>.\nIn fact, I‚Äôd wager to say that it‚Äôs almost a requirement to have some kind of\nrich text editing interface for any kind of business-user-facing web app because\nit‚Äôs such a universally needed feature.</p>\n<p>Dealing with rich text on the web is an interesting problem, but it‚Äôs interesting\nbecause it‚Äôs‚Ä¶well, uninteresting. Users have been inputting rich text for years\nin word processors like Microsoft Word, so the interaction details are somewhat known\nand established. There‚Äôs not much in the way of exciting, modern UX to build here,\nso in that sense it‚Äôs a little uninteresting. In that same sense, though, it‚Äôs also\na <em>win</em>. Anytime you can build a web experience that users already know how to\nuse and lets them get stuff done is a good thing in my opinion.</p>\n<p>However, just because it‚Äôs fairly established as a UX pattern doesn‚Äôt mean it‚Äôs\ncompletely solved as an implementation. It‚Äôs been my personal mission the last\nfew weeks to solve this problem for an app we‚Äôre building at <a href=\"https://www.hellosign.com\">HelloSign</a>,\nso I‚Äôve been deep in the weeds of this topic. During my research I found lots\nof good content on the surface-level implementation details, like which libraries\nare out there and the various techniques for building a rich text editor component.\nBut I found it difficult to find information on some of the deeper, more practical\nproblems that I was facing, like:</p>\n<ul>\n<li>How do I store this in my database?</li>\n<li>How do I handle both the editing <em>and</em> displaying of the rich text in different contexts? Are those two concepts the same thing?</li>\n<li>What about things like ‚Äúmentions‚Äù that‚Äôs not really just text?</li>\n<li>What about security?</li>\n</ul>\n<p>So I thought I‚Äôd write a bit about those particular aspects. This won‚Äôt be an\narticle about the specifics of building a rich text editor, although I may add\none of those next!</p>\n<h2 id=\"what-is-rich-text-and-why-is-it-difficult\">What is rich text and why is it difficult?</h2>\n<p>Before going further it‚Äôs probably best to give some context on what exactly I mean\nwhen referring to rich text. Here‚Äôs a quick screen shot of a rich text editor\nfrom <a href=\"https://atlaskit.atlassian.com/examples/editor/editor-core/full-page\">Atlassian‚Äôs component library</a>:</p>\n<p><img src=\"/posts/rich-text.png\" alt=\"Example of a rich text editor\"></p>\n<p>The way I think about rich text is that it‚Äôs plain text with additional structural\nand formatting information attached directly to it. I also think of rich text as\nhaving a few different vantage points:</p>\n<ul>\n<li>From the perspective of the user, it‚Äôs just text that‚Äôs visually displayed with the chosen formatting (we‚Äôll get to things like ‚Äúmentions‚Äù later).</li>\n<li>From the perspective of the browser, it‚Äôs HTML. This may seem obvious, but I find it helpful to call it out in order to distinguish this point of view from the next one.</li>\n<li>From the perspective of the developer, it‚Äôs data. Ultimately, rich text cannot be represented with just text, so it needs to be represented as some\nsort of data structure. This <em>could</em> also be HTML but it could also be another format, like JSON or markdown. More on that later.</li>\n</ul>\n<p>Having these three perspectives helped me work towards a solution that fit my\nneeds but it also highlights why this problem can be a difficult one to solve. Like most\nproblems in web development, I found that there was really no one ‚Äúcorrect‚Äù\nsolution. Each piece of the solution relied on various aspects of my own\nparticular needs. Trade offs were made.</p>\n<p>For me, I found a few of the core considerations for the problem to be:</p>\n<ul>\n<li>What kind of content will users be allowed to enter?</li>\n<li>What are all of the rendering contexts that need to be supported?</li>\n<li>How will security be handled?</li>\n<li>What other processes need to interact with the rich text content?</li>\n</ul>\n<p>Continuing to ask these core questions along the way in my research helped me\nwork towards a reasonable (<em>I hope</em> üò¨) solution.</p>\n<h2 id=\"database-storage\">Database storage</h2>\n<p>Before moving forward with much else, I wanted to have an idea of the kinds of\ninputs and outputs I‚Äôd be dealing with and how I‚Äôd store and retrieve those\nvalues from the database. There were a few options that I‚Äôd found being used\nin the community.</p>\n<h3 id=\"html\">HTML</h3>\n<p>Most WYSIWYG (<em>what-you-see-is-what-you-get</em>) editors of the past worked strictly with\nHTML. Meaning, you start with a blob of HTML and you get out a blob of HTML.\nAn example would be an editor like <a href=\"https://www.tinymce.com/\">TinyMCE</a> or <a href=\"https://ckeditor.com/\">CKEditor</a>.\nThis makes plenty of sense and existing libraries still do this today. After all,\nHTML is the language of the web. It‚Äôs a standardized, familiar syntax that‚Äôs\neasily interoperable with anything that can understand HTML.</p>\n<p>Storing the rich text value as HTML would mean storing a text value like this:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #E1E4E8\">&#x3C;</span><span style=\"color: #85E89D\">p</span><span style=\"color: #E1E4E8\">>Open the console to see the &#x3C;</span><span style=\"color: #85E89D\">em</span><span style=\"color: #E1E4E8\">>html.get&#x3C;/</span><span style=\"color: #85E89D\">em</span><span style=\"color: #E1E4E8\">> method working.&#x3C;/</span><span style=\"color: #85E89D\">p</span><span style=\"color: #E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">&#x3C;</span><span style=\"color: #85E89D\">p</span><span style=\"color: #E1E4E8\">>&#x3C;</span><span style=\"color: #85E89D\">span</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">style</span><span style=\"color: #E1E4E8\">=</span><span style=\"color: #9ECBFF\">\"font-size: 18px;\"</span><span style=\"color: #E1E4E8\">>HELLO&#x3C;/</span><span style=\"color: #85E89D\">span</span><span style=\"color: #E1E4E8\">>&#x3C;/</span><span style=\"color: #85E89D\">p</span><span style=\"color: #E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">&#x3C;</span><span style=\"color: #85E89D\">p</span><span style=\"color: #E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  &#x3C;</span><span style=\"color: #85E89D\">span</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">style</span><span style=\"color: #E1E4E8\">=</span><span style=\"color: #9ECBFF\">\"font-size: 18px;\"</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    >&#x3C;</span><span style=\"color: #85E89D\">a</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">href</span><span style=\"color: #E1E4E8\">=</span><span style=\"color: #9ECBFF\">\"https://google.com\"</span><span style=\"color: #E1E4E8\">>GOOGLE LINK&#x3C;/</span><span style=\"color: #85E89D\">a</span><span style=\"color: #E1E4E8\">>&#x3C;/</span><span style=\"color: #85E89D\">span</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  ></span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">&#x3C;/</span><span style=\"color: #85E89D\">p</span><span style=\"color: #E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">&#x3C;</span><span style=\"color: #85E89D\">p</span><span style=\"color: #E1E4E8\">>&#x3C;</span><span style=\"color: #85E89D\">br</span><span style=\"color: #E1E4E8\"> />&#x3C;/</span><span style=\"color: #85E89D\">p</span><span style=\"color: #E1E4E8\">></span></span></code></pre>\n<p>If you‚Äôre at all security-minded, storing user-generated HTML probably sets\noff some red flags. Anytime you are storing user-generated content with the intent\nof rendering that content back out on the screen, you are vulnerable to <a href=\"https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)\">XSS</a> (Cross-site-scripting)\nattacks. Technically while any user-generated content is vulnerable to this, I\nfeel it‚Äôs particularly relevant when dealing with rich text stored as HTML because\nit‚Äôs likely that it will be rendered back out <em>as</em> HTML (e.g. <code>element.innerHTML = storedHTML</code>) which is where XSS usually\ncomes in to play.</p>\n<p>That said, storing HTML is perfectly valid and is still used today. There is a way to handle it that‚Äôs\nreasonable safe. A general strategy could be to sanitize the generated HTML for XSS concerns\nand use a whitelist approached to strip out anything that you deem not appropriate.\nThere are plenty of libraries that do this (<a href=\"https://github.com/cure53/DOMPurify\">DOMPurify</a> is one).\nAnd note that you usually want to do this on <em>both</em> inputs and outputs, so sanitize\non the server before saving to the database and before rendering to the screen. This will give you a\nreasonably safe implementation, but some security devs may still not love it.\nStoring HTML in the database can feel a bit like a ticking time bomb that can blow\nup some point way in the future if you forget to follow one of the security steps\nwhen saving or rendering.</p>\n<p>A few interesting points I noticed about using HTML to store rich text values:</p>\n<p><strong>It‚Äôs very powerful for styling options</strong></p>\n<p>This can be seen as either a good thing or bad thing. In the example above, to\nbe able to display a custom font size the <code>font-size</code> property is added:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #E1E4E8\">&#x3C;</span><span style=\"color: #85E89D\">span</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">style</span><span style=\"color: #E1E4E8\">=</span><span style=\"color: #9ECBFF\">\"font-size: 18px\"</span><span style=\"color: #E1E4E8\">>words&#x3C;/</span><span style=\"color: #85E89D\">span</span><span style=\"color: #E1E4E8\">></span></span></code></pre>\n<p>This gives the client a pretty powerful mechanism for generating the exact\nvisual representation that it wants without much room for interpretation. This\ncould be a good thing if you need users to be able to expressive lots of\ndifferent visual formatting and you just want to retrieve this value from the\ndatabase and drop into an HTML page. However, there could be a case to be made\nthat it‚Äôs <em>too</em> powerful. The client could generate this:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #E1E4E8\">&#x3C;</span><span style=\"color: #85E89D\">span</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">style</span><span style=\"color: #E1E4E8\">=</span><span style=\"color: #9ECBFF\">\"font-size: 3000px\"</span><span style=\"color: #E1E4E8\">>words&#x3C;/</span><span style=\"color: #85E89D\">span</span><span style=\"color: #E1E4E8\">></span></span></code></pre>\n<p>It‚Äôs unlikely clients need the power to render font sizes at 3000 pixels!</p>\n<p><strong>It‚Äôs a more literal representation of the contents</strong></p>\n<p>The HTML generated in the example above is a very literal representation of the\ncontents. Meaning, it represents text with <em>exactly</em> a font size of 18 pixels.\nIf you‚Äôre only rendering within the context of web browsers and you want to be able to\nstick the generated content on a page and be done with it, this can be a good\noption. However I find that in some cases it can be better to leave yourself\nwith room to evolve your UI. For example, instead of saving a literal font size\nvalue maybe you save something like this:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #E1E4E8\">&#x3C;</span><span style=\"color: #85E89D\">span</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">class</span><span style=\"color: #E1E4E8\">=</span><span style=\"color: #9ECBFF\">\"f-1\"</span><span style=\"color: #E1E4E8\">>words&#x3C;/</span><span style=\"color: #85E89D\">span</span><span style=\"color: #E1E4E8\">></span></span></code></pre>\n<p>In most cases, that‚Äôs probably not what you want. Sure you can validate this\non both the client and the server, but it may become difficult to keep up with\nall of the different ways HTML can make for some horrible looking web pages.</p>\n<p>Similar to how you might style a regular webpage, you likely don‚Äôt style with\nexact pixel values but instead style with classes that represent relative values\nthat you can evolve and change over time. It also could allow you to represent\nthat text differently for different rendering contexts if you need to. For example,\nmaybe you‚Äôre rendering to a PDF that uses a different font family so the pixel\nvalue needs to be slightly different.</p>\n<p>Exploring the idea of storing my rich text as HTML began to highlight the fact that\nthere is a difference between storing the literal content of the rich text and\nstoring a <em>description</em> of the rich text. For my use case, I wanted pretty tight\ncontrol over how my rich text rendered and even had different eventual rendering\ntargets (more on that later), so I realized that if I were to use HTML I would\nessentially be using HTML as a data format. Meaning, I likely wouldn‚Äôt allow\njust <em>any</em> HTML to be stored, it would be a controlled subset with a specific\nstructure that I could potentially render in different ways to different targets.\nIn fact, there‚Äôs a good article by one of the project leads for CKEditor that\ndescribes using HTML as the data format for rich text: <a href=\"https://medium.com/content-uneditable/a-standard-for-rich-text-data-4b3a507af552\">A Standard for Rich-Text Data</a>.</p>\n<h3 id=\"markdown\">Markdown</h3>\n<p>To take a step back from HTML, my first thought for an MVP-like solution to this problem was to support <a href=\"https://daringfireball.net/projects/markdown/syntax\">Markdown</a>.\nMarkdown is a fairly well-known syntax for doing basic formatting. It‚Äôs used on\ndeveloper-centric sites like Github and StackOverflow. Markdown is a nice solution\nbecause it avoids a few of the security issues (but not all!) with HTML and doesn‚Äôt require any\nkind of special client-side components to work with. It‚Äôs still plain text when\nit‚Äôs entered by the user and only turned into HTML when saved to the database or\nrendered to the browser. The syntax is small and relatively standardized so it‚Äôs\nlikely there will be plenty of existing libraries to choose from that can take\nMarkdown and spit out HTML.</p>\n<p>The issue with Markdown is that, by design, only supports a very limited set of\nformatting. If you‚Äôre just doing bold and italic formatting, then Markdown will\nwork just fine. If you‚Äôre doing anything more complex, like colors or font families,\nthen vanilla Markdown won‚Äôt help you. There are some extensions and ‚Äúflavors‚Äù to\nMarkdown for extending the syntax, but at that point I think Markdown starts to\nlose a little bit of its original value. Markdown is not really meant to do\nmuch more than basic formatting. Anything outside of basic formatting and Markdown\nyields to just allowing arbitrary HTML, in which case you‚Äôre back to dealing\nwith all of the points mentioned in the above section.</p>\n<p>I like the idea of Markdown and I think it makes sense if you‚Äôre able to stick with\nbasic formatting.</p>\n<h3 id=\"json\">JSON</h3>\n<p>If you‚Äôve decided that you want to store a description of your rich text data to\nyour database, JSON seems like a natural choice. In fact, many modern rich text\neditors represent their contents not with HTML but with a custom data structure\nthat can be easily serialized to JSON. QuillJS has a <a href=\"https://quilljs.com/docs/delta/\">Delta</a>\nformat, ProseMirror has a <a href=\"https://prosemirror.net/docs/ref/#model.Document_Structure\">Document</a>,\nand DraftJS has its own <a href=\"https://draftjs.org/docs/api-reference-editor-state.html\">EditorState</a>.</p>\n<p>Based on what we‚Äôve discussed so far, here are some good things about storing rich\ntext as JSON:</p>\n<ul>\n<li>It‚Äôs more secure against XSS by default. You can‚Äôt just pass a string of JSON\nand render it as HTML.</li>\n<li>It can represent any kind of content and formatting you might need</li>\n<li>It can be easily parsed, validated, and manipluated by almost any system</li>\n<li>It‚Äôs a description of the content, so it can be rendered differently to different targets</li>\n</ul>\n<p>Those good things also come with some downsides:</p>\n<ul>\n<li>No standardization. There is no <em>one</em> JSON format for rich text. Each library\nimplements their own version which can lead to lock-in</li>\n<li>More code. Because you can‚Äôt just render JSON to HTML, that means you need to\nwrite code that knows how to do that.</li>\n</ul>\n<p>JSON can be a good option for any reasonably complex rich text editor needs if you‚Äôre\nwilling to write more code. A way of dealing with library and JSON format\nlock-in is to make sure you a strategy for migrating and making changes over time.\nUsing a <a href=\"http://json-schema.org/\">JSON Schema</a> definition with a version number\nis a good way to do that.</p>\n<p>There are also explorations into standard-ish formats for representing rich text.\n<a href=\"https://github.com/bustle/mobiledoc-kit\">Mobiledoc</a> and <a href=\"https://github.com/portabletext/portabletext\">Portable Text</a> are two that I‚Äôve seen in this area.</p>\n<h2 id=\"rendering-outside-of-the-editor\">Rendering outside of the editor</h2>\n<p>Another interesting consideration when thinking about rich text is where you‚Äôre\ngoing to need to render that rich text. In some cases, you only need it in the\ncontext of an editor. Something like Dropbox Paper or Google docs is an example.\nYou only ever pull that rich text up in the editor so you can be free to optimize\nfor that rendering target. But in some cases you have both the editing context\n<em>and</em> the rendering context. For example, you may be editing rich text in the\nadmin section of a blog, saving it to the database, and then rendering it back\nout on a completely separate page. In those cases, you need a way to render that\nrich text to the screen directly from the database. HTML has an advantage here\nbecause it can just be rendered directly. JSON must be encoded to HTML somehow\nfirst. Some solutions to this require that a read-only instance of a rich text\neditor be loaded up to render the custom JSON format. I‚Äôve found most rich text\nlibraries to be pretty heavy so in my opinion this is not ideal. However, a\nJSON format that is simple enough can be fairly easily encoded into HTML without\nthe need for the entire editor library. This also can help negate some of the\nsecurity issues with rendering user-generated content. A controlled ‚Äúrenderer‚Äù\nwill only render the things it knows about and likely will be rendering actual\nuser content as text, not HTML.</p>\n<h2 id=\"summary\">Summary</h2>\n<p>There‚Äôs probably a lot more I could say about rich text.\nI found it to be a deep, challenging, and, at times, overwhelming topic for a seemingly universal need for most web apps.\nFor my own use, I ended up going with <a href=\"https://prosemirror.net/\">ProseMirror</a> but it‚Äôs not without its own tradeoffs.</p>\n<h2 id=\"thanks\">Thanks</h2>\n<p>Big thanks to Atlassian for their open-source code in <a href=\"https://atlaskit.atlassian.com/\">AtlasKit</a> which was a great help in seeing how a real-world rich text eidtor could be built.</p>");

				const frontmatter = {"title":"Rich Text on the Web in 2018","date":"2018-07-04T00:00:00.000Z","description":"Thoughts on building a rich text editor"};
				const file = "/Users/nickball/code/npb/src/content/blog/rich-text-2018.md";
				const url = undefined;
				function rawContent() {
					return "\nIf you're building a web app that allows users to write free-form text in 2018,\nit's very likely that you'll come upon the need to present that text with\nvarious formatting options like **bold** or _italic_, so called [_rich text_](https://techterms.com/definition/richtext).\nIn fact, I'd wager to say that it's almost a requirement to have some kind of\nrich text editing interface for any kind of business-user-facing web app because\nit's such a universally needed feature.\n\nDealing with rich text on the web is an interesting problem, but it's interesting\nbecause it's...well, uninteresting. Users have been inputting rich text for years\nin word processors like Microsoft Word, so the interaction details are somewhat known\nand established. There's not much in the way of exciting, modern UX to build here,\nso in that sense it's a little uninteresting. In that same sense, though, it's also\na _win_. Anytime you can build a web experience that users already know how to\nuse and lets them get stuff done is a good thing in my opinion.\n\nHowever, just because it's fairly established as a UX pattern doesn't mean it's\ncompletely solved as an implementation. It's been my personal mission the last\nfew weeks to solve this problem for an app we're building at [HelloSign](https://www.hellosign.com),\nso I've been deep in the weeds of this topic. During my research I found lots\nof good content on the surface-level implementation details, like which libraries\nare out there and the various techniques for building a rich text editor component.\nBut I found it difficult to find information on some of the deeper, more practical\nproblems that I was facing, like:\n\n- How do I store this in my database?\n- How do I handle both the editing _and_ displaying of the rich text in different contexts? Are those two concepts the same thing?\n- What about things like \"mentions\" that's not really just text?\n- What about security?\n\nSo I thought I'd write a bit about those particular aspects. This won't be an\narticle about the specifics of building a rich text editor, although I may add\none of those next!\n\n## What is rich text and why is it difficult?\n\nBefore going further it's probably best to give some context on what exactly I mean\nwhen referring to rich text. Here's a quick screen shot of a rich text editor\nfrom [Atlassian's component library](https://atlaskit.atlassian.com/examples/editor/editor-core/full-page):\n\n![Example of a rich text editor](/posts/rich-text.png)\n\nThe way I think about rich text is that it's plain text with additional structural\nand formatting information attached directly to it. I also think of rich text as\nhaving a few different vantage points:\n\n- From the perspective of the user, it's just text that's visually displayed with the chosen formatting (we'll get to things like \"mentions\" later).\n- From the perspective of the browser, it's HTML. This may seem obvious, but I find it helpful to call it out in order to distinguish this point of view from the next one.\n- From the perspective of the developer, it's data. Ultimately, rich text cannot be represented with just text, so it needs to be represented as some\n  sort of data structure. This _could_ also be HTML but it could also be another format, like JSON or markdown. More on that later.\n\nHaving these three perspectives helped me work towards a solution that fit my\nneeds but it also highlights why this problem can be a difficult one to solve. Like most\nproblems in web development, I found that there was really no one \"correct\"\nsolution. Each piece of the solution relied on various aspects of my own\nparticular needs. Trade offs were made.\n\nFor me, I found a few of the core considerations for the problem to be:\n\n- What kind of content will users be allowed to enter?\n- What are all of the rendering contexts that need to be supported?\n- How will security be handled?\n- What other processes need to interact with the rich text content?\n\nContinuing to ask these core questions along the way in my research helped me\nwork towards a reasonable (_I hope_ üò¨) solution.\n\n## Database storage\n\nBefore moving forward with much else, I wanted to have an idea of the kinds of\ninputs and outputs I'd be dealing with and how I'd store and retrieve those\nvalues from the database. There were a few options that I'd found being used\nin the community.\n\n### HTML\n\nMost WYSIWYG (_what-you-see-is-what-you-get_) editors of the past worked strictly with\nHTML. Meaning, you start with a blob of HTML and you get out a blob of HTML.\nAn example would be an editor like [TinyMCE](https://www.tinymce.com/) or [CKEditor](https://ckeditor.com/).\nThis makes plenty of sense and existing libraries still do this today. After all,\nHTML is the language of the web. It's a standardized, familiar syntax that's\neasily interoperable with anything that can understand HTML.\n\nStoring the rich text value as HTML would mean storing a text value like this:\n\n```html\n<p>Open the console to see the <em>html.get</em> method working.</p>\n<p><span style=\"font-size: 18px;\">HELLO</span></p>\n<p>\n  <span style=\"font-size: 18px;\"\n    ><a href=\"https://google.com\">GOOGLE LINK</a></span\n  >\n</p>\n<p><br /></p>\n```\n\nIf you're at all security-minded, storing user-generated HTML probably sets\noff some red flags. Anytime you are storing user-generated content with the intent\nof rendering that content back out on the screen, you are vulnerable to [XSS](<https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)>) (Cross-site-scripting)\nattacks. Technically while any user-generated content is vulnerable to this, I\nfeel it's particularly relevant when dealing with rich text stored as HTML because\nit's likely that it will be rendered back out _as_ HTML (e.g. `element.innerHTML = storedHTML`) which is where XSS usually\ncomes in to play.\n\nThat said, storing HTML is perfectly valid and is still used today. There is a way to handle it that's\nreasonable safe. A general strategy could be to sanitize the generated HTML for XSS concerns\nand use a whitelist approached to strip out anything that you deem not appropriate.\nThere are plenty of libraries that do this ([DOMPurify](https://github.com/cure53/DOMPurify) is one).\nAnd note that you usually want to do this on _both_ inputs and outputs, so sanitize\non the server before saving to the database and before rendering to the screen. This will give you a\nreasonably safe implementation, but some security devs may still not love it.\nStoring HTML in the database can feel a bit like a ticking time bomb that can blow\nup some point way in the future if you forget to follow one of the security steps\nwhen saving or rendering.\n\nA few interesting points I noticed about using HTML to store rich text values:\n\n**It's very powerful for styling options**\n\nThis can be seen as either a good thing or bad thing. In the example above, to\nbe able to display a custom font size the `font-size` property is added:\n\n```html\n<span style=\"font-size: 18px\">words</span>\n```\n\nThis gives the client a pretty powerful mechanism for generating the exact\nvisual representation that it wants without much room for interpretation. This\ncould be a good thing if you need users to be able to expressive lots of\ndifferent visual formatting and you just want to retrieve this value from the\ndatabase and drop into an HTML page. However, there could be a case to be made\nthat it's _too_ powerful. The client could generate this:\n\n```html\n<span style=\"font-size: 3000px\">words</span>\n```\n\nIt's unlikely clients need the power to render font sizes at 3000 pixels!\n\n**It's a more literal representation of the contents**\n\nThe HTML generated in the example above is a very literal representation of the\ncontents. Meaning, it represents text with _exactly_ a font size of 18 pixels.\nIf you're only rendering within the context of web browsers and you want to be able to\nstick the generated content on a page and be done with it, this can be a good\noption. However I find that in some cases it can be better to leave yourself\nwith room to evolve your UI. For example, instead of saving a literal font size\nvalue maybe you save something like this:\n\n```html\n<span class=\"f-1\">words</span>\n```\n\nIn most cases, that's probably not what you want. Sure you can validate this\non both the client and the server, but it may become difficult to keep up with\nall of the different ways HTML can make for some horrible looking web pages.\n\nSimilar to how you might style a regular webpage, you likely don't style with\nexact pixel values but instead style with classes that represent relative values\nthat you can evolve and change over time. It also could allow you to represent\nthat text differently for different rendering contexts if you need to. For example,\nmaybe you're rendering to a PDF that uses a different font family so the pixel\nvalue needs to be slightly different.\n\nExploring the idea of storing my rich text as HTML began to highlight the fact that\nthere is a difference between storing the literal content of the rich text and\nstoring a _description_ of the rich text. For my use case, I wanted pretty tight\ncontrol over how my rich text rendered and even had different eventual rendering\ntargets (more on that later), so I realized that if I were to use HTML I would\nessentially be using HTML as a data format. Meaning, I likely wouldn't allow\njust _any_ HTML to be stored, it would be a controlled subset with a specific\nstructure that I could potentially render in different ways to different targets.\nIn fact, there's a good article by one of the project leads for CKEditor that\ndescribes using HTML as the data format for rich text: [A Standard for Rich-Text Data](https://medium.com/content-uneditable/a-standard-for-rich-text-data-4b3a507af552).\n\n### Markdown\n\nTo take a step back from HTML, my first thought for an MVP-like solution to this problem was to support [Markdown](https://daringfireball.net/projects/markdown/syntax).\nMarkdown is a fairly well-known syntax for doing basic formatting. It's used on\ndeveloper-centric sites like Github and StackOverflow. Markdown is a nice solution\nbecause it avoids a few of the security issues (but not all!) with HTML and doesn't require any\nkind of special client-side components to work with. It's still plain text when\nit's entered by the user and only turned into HTML when saved to the database or\nrendered to the browser. The syntax is small and relatively standardized so it's\nlikely there will be plenty of existing libraries to choose from that can take\nMarkdown and spit out HTML.\n\nThe issue with Markdown is that, by design, only supports a very limited set of\nformatting. If you're just doing bold and italic formatting, then Markdown will\nwork just fine. If you're doing anything more complex, like colors or font families,\nthen vanilla Markdown won't help you. There are some extensions and \"flavors\" to\nMarkdown for extending the syntax, but at that point I think Markdown starts to\nlose a little bit of its original value. Markdown is not really meant to do\nmuch more than basic formatting. Anything outside of basic formatting and Markdown\nyields to just allowing arbitrary HTML, in which case you're back to dealing\nwith all of the points mentioned in the above section.\n\nI like the idea of Markdown and I think it makes sense if you're able to stick with\nbasic formatting.\n\n### JSON\n\nIf you've decided that you want to store a description of your rich text data to\nyour database, JSON seems like a natural choice. In fact, many modern rich text\neditors represent their contents not with HTML but with a custom data structure\nthat can be easily serialized to JSON. QuillJS has a [Delta](https://quilljs.com/docs/delta/)\nformat, ProseMirror has a [Document](https://prosemirror.net/docs/ref/#model.Document_Structure),\nand DraftJS has its own [EditorState](https://draftjs.org/docs/api-reference-editor-state.html).\n\nBased on what we've discussed so far, here are some good things about storing rich\ntext as JSON:\n\n- It's more secure against XSS by default. You can't just pass a string of JSON\n  and render it as HTML.\n- It can represent any kind of content and formatting you might need\n- It can be easily parsed, validated, and manipluated by almost any system\n- It's a description of the content, so it can be rendered differently to different targets\n\nThose good things also come with some downsides:\n\n- No standardization. There is no _one_ JSON format for rich text. Each library\n  implements their own version which can lead to lock-in\n- More code. Because you can't just render JSON to HTML, that means you need to\n  write code that knows how to do that.\n\nJSON can be a good option for any reasonably complex rich text editor needs if you're\nwilling to write more code. A way of dealing with library and JSON format\nlock-in is to make sure you a strategy for migrating and making changes over time.\nUsing a [JSON Schema](http://json-schema.org/) definition with a version number\nis a good way to do that.\n\nThere are also explorations into standard-ish formats for representing rich text.\n[Mobiledoc](https://github.com/bustle/mobiledoc-kit) and [Portable Text](https://github.com/portabletext/portabletext) are two that I've seen in this area.\n\n## Rendering outside of the editor\n\nAnother interesting consideration when thinking about rich text is where you're\ngoing to need to render that rich text. In some cases, you only need it in the\ncontext of an editor. Something like Dropbox Paper or Google docs is an example.\nYou only ever pull that rich text up in the editor so you can be free to optimize\nfor that rendering target. But in some cases you have both the editing context\n_and_ the rendering context. For example, you may be editing rich text in the\nadmin section of a blog, saving it to the database, and then rendering it back\nout on a completely separate page. In those cases, you need a way to render that\nrich text to the screen directly from the database. HTML has an advantage here\nbecause it can just be rendered directly. JSON must be encoded to HTML somehow\nfirst. Some solutions to this require that a read-only instance of a rich text\neditor be loaded up to render the custom JSON format. I've found most rich text\nlibraries to be pretty heavy so in my opinion this is not ideal. However, a\nJSON format that is simple enough can be fairly easily encoded into HTML without\nthe need for the entire editor library. This also can help negate some of the\nsecurity issues with rendering user-generated content. A controlled \"renderer\"\nwill only render the things it knows about and likely will be rendering actual\nuser content as text, not HTML.\n\n## Summary\n\nThere's probably a lot more I could say about rich text.\nI found it to be a deep, challenging, and, at times, overwhelming topic for a seemingly universal need for most web apps.\nFor my own use, I ended up going with [ProseMirror](https://prosemirror.net/) but it's not without its own tradeoffs.\n\n## Thanks\n\nBig thanks to Atlassian for their open-source code in [AtlasKit](https://atlaskit.atlassian.com/) which was a great help in seeing how a real-world rich text eidtor could be built.\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"what-is-rich-text-and-why-is-it-difficult","text":"What is rich text and why is it difficult?"},{"depth":2,"slug":"database-storage","text":"Database storage"},{"depth":3,"slug":"html","text":"HTML"},{"depth":3,"slug":"markdown","text":"Markdown"},{"depth":3,"slug":"json","text":"JSON"},{"depth":2,"slug":"rendering-outside-of-the-editor","text":"Rendering outside of the editor"},{"depth":2,"slug":"summary","text":"Summary"},{"depth":2,"slug":"thanks","text":"Thanks"}];
				}
				async function Content() {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;
					const contentFragment = createVNode(Fragment, { 'set:html': html });
					return contentFragment;
				}
				Content[Symbol.for('astro.needsHeadRendering')] = true;

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, images, rawContent, url };
