const id = "in-search-of-mocks.md";
						const collection = "blog";
						const slug = "in-search-of-mocks";
						const body = "\nAn obsession of mine lately has been figuring out a good way for my teammates and I test React components that rely on server requests.\nSpecifically, I'm looking for ways to:\n\n- Setup a test with the _least_ amount of ceremony possible. Less ceremony means less friction for choosing to write a test or not.\n- When doing that setup, be able to only specify specifically which pieces of data I need for that test and nothing more so it's clear what's important for the test.\n- Assert what was sent to the server during my test. In some cases, this is the only way to really verify that something worked as expected.\n- Easily mock one-off errors in tests.\n- Have a good base of mocks with realistic data that can be overridden per test as needed\n\nWe're full in on the testing philosophies of [React Testing Library](We've already gone full ahead with the\n) and [Kent C. Dodds](https://kentcdodds.com), but how far do you take it?\n\nThis will be a brain dump of some of my learnings along the way for my specific scenarios, so I don't expect it to apply to everyone but I wanted to write it down anyways.\nSome things I'll be talking about:\n\n- **Mocking abstraction layers** - At which layer do you apply the mock?\n- **Mocked _data_ vs. mocked \\_responses\\_\\_** - What's the difference?\n- **Mocking your entire backend in tests _and_ the browser** - E.g. [MSW](https://mswjs.io/) or [MirageJS](https://miragejs.com/)\n\nAt the end of the day, I've concluded that a tool like [MirageJS](https://miragejs.com/) or [Mock Service Worker](https://mswjs.io/), plus some sort of in-memory database really capture everything I need.\n\n## Mocking Layers\n\n> See: [Stop Mocking Fetch](https://kentcdodds.com/blog/stop-mocking-fetch) by Kent C. Dodds.\n\nAs I mentioned above, I very much subscribe to the [Kent C. Dodds](https://kentcdodds.com/) method of testing React components.\nSpecifically, I like to test as few implementation details as possible and minimize mocking so that I can have high confidence that things are working and easily swap out implementation details.\nIn my position at work, we're constantly rebuilding and trying new experiments, so it's important to me to be able to write tests that will survive those changes.\nI'm generally less concerned with what \"kind\" of test I'm writing (unit, integration, etc.).\n\nSo knowing that, my first point of research was around figuring out which point to start mocking out server responses.\nAnd at this point I've (again) agreed with Kent that mocking at the _network_ layer is the way to go.\nKent's article above lays out a lot of this really well, but here's my own take.\n\nLet's use this code for all of the examples:\n\n```jsx\nfunction CreateLabel(props) {\n  let { api } = props;\n  let [value, setValue] = React.useState(\"\");\n  let [msg, setMsg] = React.useState(\"\");\n\n  function handleSubmit(evt) {\n    evt.preventDefault();\n\n    // Simplified for the sake of the example\n    api\n      .post(\"/label\", {\n        data: value,\n      })\n      .then(id => {\n        setMsg(`Success! Created label with id ${id}`);\n      }, err => {\n        setMsg(\"Error!\")\n      }));\n  }\n\n  return (\n    <div>\n      {msg}\n      <form onSubmit={handleSubmit}>\n        <label htmlForm=\"label\">Label</label>\n        <input\n          id=\"label\"\n          value={value}\n          onChange={evt => setValue(evt.target.value)}\n        />\n        <button type=\"submit\">Submit</button>\n      </form>\n    </div>\n  );\n}\n```\n\nA pseudo-component that shows an input and a submit button, posts to a theoretical API on submit, and then prints a message to the screen.\nAnd we'll that the theoretical API looks like this:\n\n```js\nexport let api = {\n  post(url, config) {\n    // Does some manipulation and then calls out to `fetch`\n    return fetch(url, config);\n  },\n};\n```\n\nThere are different points at which we could mock out the network call for this component.\nI see them roughly like this:\n\n- **Dependency Injection** - Test injects a mock `api` value. Network client is never hit\n- **Mocked Client** - Test mocks the network client. Environment call is never hit (`fetch` or `xhr`)\n- **Mocked Environment** - Test mocks at the environment level. Client is hit but the real `fetch` is never called\n- **Network Intercept** - Test intercepts actual network requests and allows for custom response. Real `fetch` is called and the test asserts on custom responses. (Example: Nock, MSW, Mirage)\n- **Network Intercept + Mocked data layer** - Test intercepts network requests, but requests are handled with actual logic mimicking production code and write to an in-memory database. Tests assert on the database. (Example: Mirage JS)\n\n![Mocking layer](/posts/mock-layer.png)\n\n### Dependency Injection / Mocking `fetch`\n\nFor a long time I really only considered two ways of mocking this component: Dependency injection or mocking the client.\nDependency injection would look like this:\n\n> I'm using [React Testing Library](https://testing-library.com/docs/react-testing-library) here.\n\n```jsx\ntest(\"CreateLabel can create a label\", async () => {\n  // In a test\n  let mockApi = {\n    post: jest.fn(() => Promise.resolve(123)),\n  };\n  render(<CreateLabel api={mockApi} />);\n\n  // Type a value into the input, then submit\n  type(screen.getByLabelText(\"Label\"), \"Home\"));\n  click(screen.getByRole('button', { name: \"Submit\" });\n\n  // Assert we called our mocked API\n  await waitFor(() => expect(mockApi.post).toHaveBeenCalledTimes(1));\n\n  // Assert we called our mocked API _with_ the value we typed\n  expect(mockApi.post).toHaveBeenCalledWith(\"/label\", { data: \"Home\" });\n\n  // Assert that we used the value returned from our API and printed it to the screen\n  expect(screen.queryByText(\"Success! Created label with id 123\")).toBeInTheDocument()\n});\n```\n\nWe're passing in a mocked API so that we can make a direct assertion on what was called.\nThis is kind of nice because everything is in one spot and there aren't many abstraction layers, so things are easy to follow.\n\nHowever, as stated in Kent's article above, this strategy has some downsides as well:\n\n- It doesn't exercise the logic in the `api` at all. A separate test is needed for that.\n- It ties your API implementation details to your component. In your test, you have to know that your component calls `api.post`. If you later change this logic, you'll have to update your test.\n- Further on the last point, your response from your mock API is hard-coded. If you later change your API response to return an object like `{ id: 1}`, you'll have to update your test.\n\nA closely related strategy to this is mocking one level up at the `fetch` level.\nThat might look like this:\n\n```jsx\ntest(\"CreateLabel can create a label\", async () => {\n  fetch.mockImplementationOnce(() => Promise.resolve(123))\n\n  render(<CreateLabel />);\n\n  // Type a value into the input, then submit\n  type(screen.getByLabelText(\"Label\"), \"Home\"));\n  click(screen.getByRole('button', { name: \"Submit\" });\n\n  // Assert we called our mocked API\n  await waitFor(() => expect(fetch).toHaveBeenCalledTimes(1));\n\n  // Assert we called our mocked API _with_ the value we typed\n  expect(fetch).toHaveBeenCalledWith(\"/label\", { data: \"Home\" });\n\n  // Assert that we used the value returned from our API and printed it to the screen\n  expect(screen.queryByText(\"Success! Created label with id 123\")).toBeInTheDocument()\n});\n```\n\nThis is better than dependency injection because we're now excercising our `api` logic and removing some implementation details in our test.\nBut, we still have the issue of hard-coding the response from the API _and_ we can also see another implementation detail: `fetch`!\nThe fact that we're mocking `fetch` means that we're not actually testing that we're calling `fetch` with the correct arguments.\n\nTo move further up the mocking layer, let's talk about some other things first.\n\n## Mocked Responses vs. Mocked Data\n\nSo let's say you're convinced that mocking at the `environment` isn't the best solution.\nThe next layer for mocking would be to call the APIs in the environment that make network calls, but intercept those calls so they don't actually hit the network.\nThis is where something like [`msw`](https://mswjs.io/) comes in:\n\n```jsx\nimport { rest } from 'msw';\nimport { server } from './test/server';\n\ntest(\"CreateLabel can create a label\", async () => {\n\n  // Tell our \"server\" to intercept POST requests to `/label` and respond\n  // with this specific response\n  server.use(\n    rest.post('/label', (req, res, ctx) => res(ctx.text(123)))\n  )\n\n  render(<CreateLabel />);\n\n  // Type a value into the input, then submit\n  type(screen.getByLabelText(\"Label\"), \"Home\"));\n  click(screen.getByRole('button', { name: \"Submit\" });\n\n  // Assert that we used the value returned from our API and printed it to the screen\n  expect(screen.queryByText(\"Success! Created label with id 123\")).toBeInTheDocument()\n});\n```\n\nThis is interesting because there's no mocking of `fetch` anywhere.\nWe could theoretically switch our entire client layer to use `xhr` if we wanted and this test would still pass.\n\nYou may have noticed that we're no longer asserting what we called our API with.\nWe could still do that here by making the response a mocked function.\n\n```jsx\nimport { rest } from 'msw';\nimport { server } from './test/server';\n\ntest(\"CreateLabel can create a label\", async () => {\n\n  // Tell our \"server\" to intercept POST requests to `/label` and respond\n  // with this specific response\n\n  // Use a mock function that we can assert on later\n  let handler = jest.fn((req, res, ctx) => res(ctx.text(123)))\n\n  server.use(rest.post('/label', handler))\n\n  render(<CreateLabel />);\n\n  // Type a value into the input, then submit\n  type(screen.getByLabelText(\"Label\"), \"Home\"));\n  click(screen.getByRole('button', { name: \"Submit\" });\n\n  // Assert we called our mocked API\n  await waitFor(() => expect(handler).toHaveBeenCalledTimes(1));\n\n  // Assert things about the last call. This will be a bit cumbersome because\n  // it's the full request. Likely could create a helper like:\n  expect(getLastRequestBody(handler)).toHaveBeenCalledWith({\n    data: \"Home\"\n  })\n\n  // Assert that we used the value returned from our API and printed it to the screen\n  expect(screen.queryByText(\"Success! Created label with id 123\")).toBeInTheDocument()\n});\n```\n\nThis is pretty good!\nBut, there are still a few short-comings with this:\n\n- The test is still coupled to the network API details through the URL of the request. If we want to change the endpoint this component hits, we'll have to update our test. This could be a perfectly fine trade-off depending on your needs.\n- We're still hard-coding the response payload in the test. If we have other tests that hit this endpoint, we'd be hard-coding that data there as well. If the payload changes, we'd need to update all places that use it.\n\nAnother interesting short-coming is that as things get more complicated in your app, you essentially have to implicitly implement your backend logic through your mocks.\nHere's an example of what I mean:\n\nSay that our example above actually makes _two_ network calls: One that posts to create the label, and then another that refetches all labels to get the latest data:\n\n```jsx\nfunction CreateLabel(props) {\n  /* ... */\n\n  function handleSubmit(evt) {\n    evt.preventDefault();\n\n    // This is simplified for the sake of the example\n    api\n      .post(\"/label\", {\n        data: value,\n      })\n      .then(id => {\n        setMsg(`Success! Created label with id ${id}`);\n\n        // Refetch all labels so we have the latest data\n        return refetchAllLabels()\n      }, err => {\n        setMsg(\"Error!\")\n      }));\n  }\n\n  /* ... */\n}\n```\n\nAssuming we want to assert something about that refetching in our tests, we have to set that up in our mocks;\n\n```jsx\nimport { rest } from \"msw\";\nimport { server } from \"./test/server\";\n\ntest(\"CreateLabel can create a label\", async () => {\n  // Tell our \"server\" to intercept POST requests to `/label` and respond\n  // with this specific response\n\n  // Use a mock function that we can assert on later\n  let handler = jest.fn((req, res, ctx) => res(ctx.text(123)));\n\n  server.use(\n    rest.post(\"/label\", handler),\n\n    // Intercept this request too and ensure we're returning the same data\n    // that our mocked post handler did\n    rest.get(\"/labels\", (req, res, ctx) => res(ctx.data([123])))\n  );\n\n  render(<CreateLabel />);\n\n  // ...\n});\n```\n\nWe have to intercept two requests now and line up each response so that they return related data, so in a sense we're doing what our backend would be doing with these requests.\nYou could say that this is unnecessary to do because the tests don't _really_ care that the same data exists in both responses, they just care that your response is what you said it would be.\nThis is fair, but in my opinion I think it also dilutes the readability of the test.\nI think it's helpful to see in my test that, yes, this the endpoint returns the data that was created in this other endpoint because they are related and that's how the real thing works.\nBy encoding this information into mocks, you have this info spread through all of your tests.\n\nSo let's go one step further...\n\n## Mocking Your Entire Backend\n\nInstead of mocking individual requests, we can actual mock the _handlers_ of those requests and write to a mocked in-memory database.\nThe difference here is subtle, but interesting.\nIt's mostly easily demonstrated in the udpated test:\n\n```jsx\nimport { rest } from 'msw';\nimport { server, db } from './test/server';\n\ntest(\"CreateLabel can create a label\", async () => {\n  render(<CreateLabel />);\n\n  // Type a value into the input, then submit\n  type(screen.getByLabelText(\"Label\"), \"Home\"));\n  click(screen.getByRole('button', { name: \"Submit\" });\n\n  // Assert we called our mocked API\n  await waitFor(() => expect(db.getLabels()).toHaveLength(1))\n\n  let label = db.getLabels()[0]\n\n  expect(label.title).toBe('Home')\n\n  // Assert that we used the value returned from our API and printed it to the screen\n  expect(screen.queryByText(`Success! Created label with id ${label.id}`)).toBeInTheDocument()\n});\n```\n\nA couple of interesting things to point out:\n\n- We don't mock each individual response, so the test is a lot shorter.\n- We don't assert the arguments of the request, we _assert_ the result of the database.\n- We're asserting _less_ about our implementation details. This may feel uncomfortable.\n\nIf you've ever written or peered into a backend test, it probably looks a lot like this.\nYou set up some things for the tests, perform an action, and then assert on the database.\nThe fact that our frontend test does this same thing is nice because I think it helps solidify the mental model of what's actually happening.\n\nSetting this up with `msw` would depend on how you're making requests.\nIn my case, I'm typically using GraphQL so I'll show that as an example.\nGraphQL is especially interesting because there's really only one endpoint and all of the logic is in the resolvers.\n\n```js\n// test/server.js\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport schema from './my-schema.graphql';\n\nlet db = /* ... */\n\nlet root = {\n  createPost(args, { db }) {\n    let { title } = args;\n\n    // Make a new 'post' in our database\n    let newPost = db.create('post', { title })\n    return newPost;\n  },\n  posts(_args, { db }) {\n    // Return all of the posts in our db\n    return db.get('post');\n  }\n}\n\nexport let server = setupServer(\n  rest.post('/api/graphql', async (req, res, ctx) => {\n    // Get the query and variables from the body\n    let { query, variables } = req.body;\n    let context = { db };\n\n    // Make a real query against our schema!\n    let response = await graphql(schema, query, root, context, variables);\n\n    return res(ctx.delay(500), ctx.status(200), ctx.json(response));\n  })\n)\n```\n\nAs for the \"database\", it can be just about as simple or complicated as you want.\n\n```js\nlet data = {\n  post: {},\n};\n\nexport let db = {\n  create(model, attrs) {\n    let id = makeId();\n\n    let thing = {\n      id,\n      ...attrs,\n    };\n\n    data[model][id] = thing;\n\n    return thing;\n  },\n};\n```\n\nPositives of this type of test are:\n\n- All of your 'backend' mocking logic lives in one spot. It can be updated here and all tests will get the udpates.\n- It removes _all_ implementation details from your test. Not even which endpoints you are calling are part of the test.\n- It's (in theory) very close to how the real system works\n- In the case of GraphQL, it's making a real query against your real schema. It can catch if you are returning responses that don't match the schema, which ensures your test data always resembles production.\n\nDownsides are:\n\n- There's a lot more abstraction. It's now harder to see in your test everything that's in your component under test\n- More test logic in the request handlers. The test is actually asserting on the test database logic, which can have its own bugs.\n\nAll together, this pattern essentially does what [MirageJS](https://miragejs.com/) does but I wanted to show that it can be done with msw as well.\nThe interesting thing about both of these tools, is that you can use both of them in the browser as well!\nSo you now have a way to develop new features against real data using the same production-like data you use in your tests.\n\n## Slippery Slope\n\nOne argument I'm primed to take on with my co-workers is that this is essentially rebuilding our backend on the frontend.\nIn this simple example, the resolvers are easy, but in a real app things are complicated.\nThere are relationships between models and service calls to be made, etc.\nThat's all true and I think a trade off to be made for each team.\nBut at the end of the day, I think if you think of it as a development tool first, it will always be helpful.\nThe point is not to faithfully recreate exactly what your backend is doing, but to give an approximation of it and to have all of the logic in one place.\nRemember, it's only a slight extension of doing this at the request level.\nAnd ultimately, being able to hop down to mock out the request level should be the escape hatch.\nIf you have a test that's asserting on a complicated backend response, write a one-off request mock.\nUse your shared database for mocks that are easy and can be reused across tests.\nWriting my tests like a backend test with a database feels very strange at first, but I've found that it actually solidifies my understading of features _more_.\n\n## Wrap Up\n\nI'm still exploring all of this, but so far I'm pretty happy with this setup.\nIt ticks all of my boxes and feels like the right trade offs have been made...for now.\nTo sum up my current ideal setup, I've created a repo: [https://github.com/npbee/msw-jest-graphql](https://github.com/npbee/msw-jest-graphql).\n";
						const data = {title:"In Search of Mocks",date:new Date(1592179200000),description:"A journey through various data mocking techniques for testing React apps (and GraphQL)"};
						const _internal = {
							type: 'content',
							filePath: "/Users/nickball/code/npb/src/content/blog/in-search-of-mocks.md",
							rawData: "\ntitle: In Search of Mocks\ndate: 2020-06-15\ndescription: A journey through various data mocking techniques for testing React apps (and GraphQL)",
						};

export { _internal, body, collection, data, id, slug };
