import { j as createVNode, F as Fragment, k as spreadAttributes } from './astro.c61b1d12.mjs';
import 'cookie';
import 'kleur/colors';
import 'path-to-regexp';
import 'mime';
import 'string-width';
import 'html-escaper';

const images = {
					
				};

				function updateImageReferences(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="([^"]+)"/gm,
						(full, imagePath) => spreadAttributes({src: images[imagePath].src, ...images[imagePath].attributes})
					);
				}

				const html = updateImageReferences("<blockquote>\n<p>This is a post in a series of posts about learning back-end topics as a front-end developer.</p>\n</blockquote>\n<p>Along with learning full-stack topics recently, I‚Äôve also been learning <a href=\"https://elixir-lang.org/\">Elixir</a>. I‚Äôll be honest, I‚Äôm not sure I would have been so interested in learning about back-end things if it weren‚Äôt for the added bonus of getting to use Elixir to do so. I‚Äôve always had an interest in functional programming and other functional languages. I typically write JavaScript in a functional fashion and I‚Äôve toyed with other specifically functional languages like Elm, Clojure, and even Haskell. In the little time that I‚Äôve spent venturing outside the comfortable world of JavaScript, I‚Äôve found that learning other languages can unlock patterns and paradigms that I may not have otherwise grasped. Even though these patterns may not be directly usable in JavaScript, they can still give perspective and sometimes even make the patterns that <em>do</em> exist more understandable. It feels a little like ‚Äúleveling up.‚Äù</p>\n<h2 id=\"first-impressions\">First Impressions</h2>\n<p>Overall: fantastic. A few specific things that I enjoyed immediately:</p>\n<p><strong>Documentation</strong></p>\n<p>Docs are a first-class concept in Elixir and it shows. Packages can easily build docs from code and they all follow a <a href=\"https://hexdocs.pm/elixir/Kernel.html\">similar</a> design layout. This makes browsing documentation familiar regardless of the package. And bonus, the documentation works in the REPL!</p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/npbee/2017/learning-elixir/iex-docs.png\" alt=\"iex docs\"></p>\n<p><strong>Testing</strong></p>\n<p>This is another first-class topic that has built-in support in Elixir. I‚Äôve found testing to be simple and intuitive for most cases.</p>\n<p><strong>Mix</strong></p>\n<p>Mix is the build tool for Elixir that allows you to run tasks, compile, fetch dependencies, etc. As a front-end developer, it‚Äôs similar to <code>npm</code> so it quickly made sense.</p>\n<p><strong>Community</strong></p>\n<p>I‚Äôve found the community to be very friendly and inclusive. I even submitted a <a href=\"https://github.com/elixir-lang/elixir/pull/6310\">pull request</a> to the language!</p>\n<p><strong>Functional Goodness</strong></p>\n<p>And of course, I love that it‚Äôs a functional language. Writing in a functional style is one thing, but writing functional code in a functional language is another. Being able to write lots of concise functions and combine them into a larger applications is my preferred way to write applications and Elixir seems to be designed just for that.</p>\n<p>And <a href=\"https://elixir-lang.org/getting-started/pattern-matching.html\">pattern matching</a> is üòç.</p>\n<h2 id=\"second-impressions\">Second Impressions</h2>\n<p>Overall: still great. A few things that I started to struggle with:</p>\n<p><strong>Composing Functions</strong></p>\n<p>One thing that I love about writing functional code is composing functions together. By that I mean:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A737D\">// In pseudo-javascript</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">add1</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> (</span><span style=\"color: #FFAB70\">x</span><span style=\"color: #E1E4E8\">) </span><span style=\"color: #F97583\">=></span><span style=\"color: #E1E4E8\"> x </span><span style=\"color: #F97583\">+</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">1</span><span style=\"color: #E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">times2</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> (</span><span style=\"color: #FFAB70\">x</span><span style=\"color: #E1E4E8\">) </span><span style=\"color: #F97583\">=></span><span style=\"color: #E1E4E8\"> x </span><span style=\"color: #F97583\">*</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">2</span><span style=\"color: #E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">math</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">compose</span><span style=\"color: #E1E4E8\">(add1, times2);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #B392F0\">math</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #79B8FF\">2</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color: #6A737D\">//=> 5</span></span></code></pre>\n<p>But surprisingly, this way of composing functions is not really used much that I‚Äôve seen. The Elixir way of doing this might instead use the <a href=\"https://elixir-lang.org/getting-started/enumerables-and-streams.html#the-pipe-operator\">pipe operator</a>.</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F97583\">defmodule</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">Math</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">do</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">\t</span><span style=\"color: #F97583\">def</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">add1</span><span style=\"color: #E1E4E8\">(x) </span><span style=\"color: #F97583\">do</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">\t  x </span><span style=\"color: #F97583\">+</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">\t</span><span style=\"color: #F97583\">end</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">\t</span><span style=\"color: #F97583\">def</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">times</span><span style=\"color: #E1E4E8\">(x) </span><span style=\"color: #F97583\">do</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">\t  x </span><span style=\"color: #F97583\">*</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">2</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">\t</span><span style=\"color: #F97583\">end</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">\t</span><span style=\"color: #F97583\">def</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">math</span><span style=\"color: #E1E4E8\">(x) </span><span style=\"color: #F97583\">do</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">\t  x</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">\t  </span><span style=\"color: #F97583\">|></span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">times2</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">\t  </span><span style=\"color: #F97583\">|></span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">add1</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">\t</span><span style=\"color: #F97583\">end</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">end</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #B392F0\">Math</span><span style=\"color: #E1E4E8\">.</span><span style=\"color: #B392F0\">math</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #79B8FF\">2</span><span style=\"color: #E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color: #6A737D\">#=> 5</span></span></code></pre>\n<p>While everything you can do with compose can be accomplished by just defining functions, I do miss the <code>compose</code> function. The pipe operator is great, though!</p>\n<p><strong>Pragmatism</strong></p>\n<p>The pragmatic approach to the language is something that I‚Äôve seen referred to a number of times. Pragmatism may have a different meaning to other people, but for me it mostly just means it can help you get things done. Elixir is a functional language, but it‚Äôs not <em>pure</em> functional language. That means you can do things like perform side effects in functions. While I generally try my darnedest to <em>not</em> rely on side effects, I will say that it‚Äôs nice to be use them on occasion. Writing completely side-effect free code takes diligence from an entire team and I can understand how that may be a hinderance to small teams trying to push out features. Overall I‚Äôve found Elixir to have a nice balance of strictness and pragmatism that‚Äôs resulted in some really maintainable code.</p>\n<h2 id=\"similarities--differences\">Similarities / Differences</h2>\n<p>As I‚Äôve gone through learning Elixir and implementing various features, I‚Äôve started to notice how things <em>somewhat</em> relate to familiar front-end concepts for me. Most of these comparisons are definitely not one-to-one, but I think they have helped me solidify a few things in my mind.</p>\n<p><strong>Elixir Compiler ~ Babel</strong></p>\n<p>Elixir is a compiled language, so that means before you can do anything with it, you have to transform it into something else. In the case of Elixir, your source code is compiled into Erlang. In the case of most modern JavaScript, your source code is compiled into‚Ä¶well, different JavaScript. Elixir is compiling into a completely different language whereas JavaScript is just compiling into a different version of itself. It might be an even closer comparison if you happen to be using experimental JavaScript syntax, like maybe the <a href=\"https://github.com/tc39/proposal-pipeline-operator\">pipe operator</a>. In that case, you‚Äôre using syntax that <em>must</em> be transformed into code that the browser can understand, so you‚Äôre essentially writing a different language.</p>\n<p><strong>Pattern Matching ~ Destructuring</strong></p>\n<p>This comparison is a bit of a stretch, but I can‚Äôt help but note the syntactical similarities. In Elixir, you can use pattern matching to do something like:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A737D\"># pattern matching</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">%{</span><span style=\"color: #79B8FF\">a:</span><span style=\"color: #E1E4E8\"> a, </span><span style=\"color: #79B8FF\">b:</span><span style=\"color: #E1E4E8\"> b} </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> %{</span><span style=\"color: #79B8FF\">a:</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">1</span><span style=\"color: #E1E4E8\">, </span><span style=\"color: #79B8FF\">b:</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">2</span><span style=\"color: #E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color: #6A737D\">#=> a == 1</span></span>\n<span class=\"line\"><span style=\"color: #6A737D\">#=> b == 2</span></span></code></pre>\n<p>In JavaScript, you could do:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A737D\">// Destructuring</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> { </span><span style=\"color: #79B8FF\">a</span><span style=\"color: #E1E4E8\">, </span><span style=\"color: #79B8FF\">b</span><span style=\"color: #E1E4E8\"> } </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> { a: </span><span style=\"color: #79B8FF\">1</span><span style=\"color: #E1E4E8\">, b: </span><span style=\"color: #79B8FF\">2</span><span style=\"color: #E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color: #6A737D\">//=> a === 1</span></span>\n<span class=\"line\"><span style=\"color: #6A737D\">//=> b === 2</span></span></code></pre>\n<p>These two things are definitely <em>not</em> the same, but somehow I think learning about restructuring first gave me a head start on pattern matching. The downside is that it can be a little sad when you try to write an Elixir pattern match in JavaScript and realize you can‚Äôt!</p>\n<p><strong>OTP ~ Redux</strong></p>\n<p><a href=\"https://elixirschool.com/en/lessons/advanced/otp-concurrency/\">OTP</a> is one of the core principles of Elixir and Erlang. I can‚Äôt say that I‚Äôve mastered it yet, but I can almost see similarities with <a href=\"http://redux.js.org/\">Redux</a>. When you use a <a href=\"https://elixir-lang.org/getting-started/mix-otp/genserver.html\">GenServer</a> in Elixir, there‚Äôs this idea of functions that handle specific calls by receiving the state, doing something with it, and returning a new state:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F97583\">defmodule</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">SimpleGenServer</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">do</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">use</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">GenServer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #6A737D\">### ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">def</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">handle_call</span><span style=\"color: #E1E4E8\">({</span><span style=\"color: #79B8FF\">:add</span><span style=\"color: #E1E4E8\">, value}, </span><span style=\"color: #6A737D\">_from</span><span style=\"color: #E1E4E8\">, state) </span><span style=\"color: #F97583\">do</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    {</span><span style=\"color: #79B8FF\">:reply</span><span style=\"color: #E1E4E8\">, value, state </span><span style=\"color: #F97583\">+</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">1</span><span style=\"color: #E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">end</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #6A737D\">### ...</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">end</span></span></code></pre>\n<p>This could be seen as a type of reducer from Redux:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F97583\">function</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">reducer</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #FFAB70\">state</span><span style=\"color: #E1E4E8\">, </span><span style=\"color: #FFAB70\">action</span><span style=\"color: #E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">switch</span><span style=\"color: #E1E4E8\"> (action.type) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">case</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #9ECBFF\">\"ADD\"</span><span style=\"color: #E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      </span><span style=\"color: #F97583\">return</span><span style=\"color: #E1E4E8\"> state </span><span style=\"color: #F97583\">+</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">1</span><span style=\"color: #E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">default</span><span style=\"color: #E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      </span><span style=\"color: #F97583\">return</span><span style=\"color: #E1E4E8\"> state;</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">}</span></span></code></pre>\n<p>Of course, OTP is much more robust.</p>\n<p><strong>Macros ~ Babel Transforms?</strong></p>\n<p><a href=\"https://elixir-lang.org/getting-started/meta/macros.html\">Macros</a> are the sort of thing that can really break your brain the first time you try to learn about them. Using macros, you can write code that <em>writes</em> code. Because Elixir is compiled, it allows you to hook into that compilation step and use it to your advantage to write things like custom syntax or help with code reuse. In JavaScript land, Babel transforms could be potentially thought of as macros. For example, <a href=\"https://facebook.github.io/react/docs/jsx-in-depth.html\">JSX</a> turns this:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #E1E4E8\">&#x3C;</span><span style=\"color: #85E89D\">div</span><span style=\"color: #E1E4E8\">>hello&#x3C;/</span><span style=\"color: #85E89D\">div</span><span style=\"color: #E1E4E8\">></span></span></code></pre>\n<p>‚Ä¶into this when Babel compiles it:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #E1E4E8\">React.</span><span style=\"color: #B392F0\">createElement</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\"div\"</span><span style=\"color: #E1E4E8\">, {}, </span><span style=\"color: #9ECBFF\">\"hello\"</span><span style=\"color: #E1E4E8\">);</span></span></code></pre>\n<p>There‚Äôs nothing stopping you from writing the compiled version, but using the Babel transform can make things clearer or faster to write (if you‚Äôre into JSX).</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>I‚Äôve really enjoyed learning Elixir and I‚Äôm excited to keep going with it. Besides JavaScript, it‚Äôs the only other language I‚Äôve really taken a deep dive on and I think it‚Äôs been a great second language to learn. Topics like macros and concurrency are challenging in any language, but I think learning them with Elixir has been very approachable.</p>");

				const frontmatter = {"title":"Learning Elixir","date":"2017-08-20T00:00:00.000Z","description":"Some thoughts on learning the Elixir language."};
				const file = "/Users/nickball/code/npb/src/content/blog/learning-elixir.md";
				const url = undefined;
				function rawContent() {
					return "\n> This is a post in a series of posts about learning back-end topics as a front-end developer.\n\nAlong with learning full-stack topics recently, I've also been learning [Elixir](https://elixir-lang.org/). I'll be honest, I'm not sure I would have been so interested in learning about back-end things if it weren't for the added bonus of getting to use Elixir to do so. I've always had an interest in functional programming and other functional languages. I typically write JavaScript in a functional fashion and I've toyed with other specifically functional languages like Elm, Clojure, and even Haskell. In the little time that I've spent venturing outside the comfortable world of JavaScript, I've found that learning other languages can unlock patterns and paradigms that I may not have otherwise grasped. Even though these patterns may not be directly usable in JavaScript, they can still give perspective and sometimes even make the patterns that _do_ exist more understandable. It feels a little like \"leveling up.\"\n\n## First Impressions\n\nOverall: fantastic. A few specific things that I enjoyed immediately:\n\n**Documentation**\n\nDocs are a first-class concept in Elixir and it shows. Packages can easily build docs from code and they all follow a [similar](https://hexdocs.pm/elixir/Kernel.html) design layout. This makes browsing documentation familiar regardless of the package. And bonus, the documentation works in the REPL!\n\n![iex docs](https://s3-us-west-2.amazonaws.com/npbee/2017/learning-elixir/iex-docs.png)\n\n**Testing**\n\nThis is another first-class topic that has built-in support in Elixir. I've found testing to be simple and intuitive for most cases.\n\n**Mix**\n\nMix is the build tool for Elixir that allows you to run tasks, compile, fetch dependencies, etc. As a front-end developer, it's similar to `npm` so it quickly made sense.\n\n**Community**\n\nI've found the community to be very friendly and inclusive. I even submitted a [pull request](https://github.com/elixir-lang/elixir/pull/6310) to the language!\n\n**Functional Goodness**\n\nAnd of course, I love that it's a functional language. Writing in a functional style is one thing, but writing functional code in a functional language is another. Being able to write lots of concise functions and combine them into a larger applications is my preferred way to write applications and Elixir seems to be designed just for that.\n\nAnd [pattern matching](https://elixir-lang.org/getting-started/pattern-matching.html) is üòç.\n\n## Second Impressions\n\nOverall: still great. A few things that I started to struggle with:\n\n**Composing Functions**\n\nOne thing that I love about writing functional code is composing functions together. By that I mean:\n\n```javascript\n// In pseudo-javascript\nconst add1 = (x) => x + 1;\nconst times2 = (x) => x * 2;\nconst math = compose(add1, times2);\n\nmath(2);\n//=> 5\n```\n\nBut surprisingly, this way of composing functions is not really used much that I've seen. The Elixir way of doing this might instead use the [pipe operator](https://elixir-lang.org/getting-started/enumerables-and-streams.html#the-pipe-operator).\n\n```elixir\ndefmodule Math do\n\tdef add1(x) do\n\t  x + 1\n\tend\n\n\tdef times(x) do\n\t  x * 2\n\tend\n\n\tdef math(x) do\n\t  x\n\t  |> times2\n\t  |> add1\n\tend\nend\n\nMath.math(2)\n#=> 5\n```\n\nWhile everything you can do with compose can be accomplished by just defining functions, I do miss the `compose` function. The pipe operator is great, though!\n\n**Pragmatism**\n\nThe pragmatic approach to the language is something that I've seen referred to a number of times. Pragmatism may have a different meaning to other people, but for me it mostly just means it can help you get things done. Elixir is a functional language, but it's not _pure_ functional language. That means you can do things like perform side effects in functions. While I generally try my darnedest to _not_ rely on side effects, I will say that it's nice to be use them on occasion. Writing completely side-effect free code takes diligence from an entire team and I can understand how that may be a hinderance to small teams trying to push out features. Overall I've found Elixir to have a nice balance of strictness and pragmatism that's resulted in some really maintainable code.\n\n## Similarities / Differences\n\nAs I've gone through learning Elixir and implementing various features, I've started to notice how things _somewhat_ relate to familiar front-end concepts for me. Most of these comparisons are definitely not one-to-one, but I think they have helped me solidify a few things in my mind.\n\n**Elixir Compiler ~ Babel**\n\nElixir is a compiled language, so that means before you can do anything with it, you have to transform it into something else. In the case of Elixir, your source code is compiled into Erlang. In the case of most modern JavaScript, your source code is compiled into...well, different JavaScript. Elixir is compiling into a completely different language whereas JavaScript is just compiling into a different version of itself. It might be an even closer comparison if you happen to be using experimental JavaScript syntax, like maybe the [pipe operator](https://github.com/tc39/proposal-pipeline-operator). In that case, you're using syntax that _must_ be transformed into code that the browser can understand, so you're essentially writing a different language.\n\n**Pattern Matching ~ Destructuring**\n\nThis comparison is a bit of a stretch, but I can't help but note the syntactical similarities. In Elixir, you can use pattern matching to do something like:\n\n```elixir\n# pattern matching\n%{a: a, b: b} = %{a: 1, b: 2}\n#=> a == 1\n#=> b == 2\n```\n\nIn JavaScript, you could do:\n\n```javascript\n// Destructuring\nconst { a, b } = { a: 1, b: 2 };\n//=> a === 1\n//=> b === 2\n```\n\nThese two things are definitely _not_ the same, but somehow I think learning about restructuring first gave me a head start on pattern matching. The downside is that it can be a little sad when you try to write an Elixir pattern match in JavaScript and realize you can't!\n\n**OTP ~ Redux**\n\n[OTP](https://elixirschool.com/en/lessons/advanced/otp-concurrency/) is one of the core principles of Elixir and Erlang. I can't say that I've mastered it yet, but I can almost see similarities with [Redux](http://redux.js.org/). When you use a [GenServer](https://elixir-lang.org/getting-started/mix-otp/genserver.html) in Elixir, there's this idea of functions that handle specific calls by receiving the state, doing something with it, and returning a new state:\n\n```elixir\ndefmodule SimpleGenServer do\n  use GenServer\n\n  ### ...\n\n  def handle_call({:add, value}, _from, state) do\n    {:reply, value, state + 1}\n  end\n\n  ### ...\nend\n```\n\nThis could be seen as a type of reducer from Redux:\n\n```js\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"ADD\":\n      return state + 1;\n    default:\n      return state;\n  }\n}\n```\n\nOf course, OTP is much more robust.\n\n**Macros ~ Babel Transforms?**\n\n[Macros](https://elixir-lang.org/getting-started/meta/macros.html) are the sort of thing that can really break your brain the first time you try to learn about them. Using macros, you can write code that _writes_ code. Because Elixir is compiled, it allows you to hook into that compilation step and use it to your advantage to write things like custom syntax or help with code reuse. In JavaScript land, Babel transforms could be potentially thought of as macros. For example, [JSX](https://facebook.github.io/react/docs/jsx-in-depth.html) turns this:\n\n```javascript\n<div>hello</div>\n```\n\n...into this when Babel compiles it:\n\n```javascript\nReact.createElement(\"div\", {}, \"hello\");\n```\n\nThere's nothing stopping you from writing the compiled version, but using the Babel transform can make things clearer or faster to write (if you're into JSX).\n\n## Conclusion\n\nI've really enjoyed learning Elixir and I'm excited to keep going with it. Besides JavaScript, it's the only other language I've really taken a deep dive on and I think it's been a great second language to learn. Topics like macros and concurrency are challenging in any language, but I think learning them with Elixir has been very approachable.\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"first-impressions","text":"First Impressions"},{"depth":2,"slug":"second-impressions","text":"Second Impressions"},{"depth":2,"slug":"similarities--differences","text":"Similarities / Differences"},{"depth":2,"slug":"conclusion","text":"Conclusion"}];
				}
				async function Content() {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;
					const contentFragment = createVNode(Fragment, { 'set:html': html });
					return contentFragment;
				}
				Content[Symbol.for('astro.needsHeadRendering')] = true;

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, images, rawContent, url };
