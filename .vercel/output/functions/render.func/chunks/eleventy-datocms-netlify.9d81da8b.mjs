import { j as createVNode, F as Fragment, k as spreadAttributes } from './astro.c61b1d12.mjs';
import 'cookie';
import 'kleur/colors';
import 'path-to-regexp';
import 'mime';
import 'string-width';
import 'html-escaper';

const images = {
					
				};

				function updateImageReferences(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="([^"]+)"/gm,
						(full, imagePath) => spreadAttributes({src: images[imagePath].src, ...images[imagePath].attributes})
					);
				}

				const html = updateImageReferences("<p>As a web developer I get the occasional ask from friends to help them build a\nwebsite. I generally don’t mind and am happy to help out my buddies, but lately\nas I’ve been limited on spare time, I’ve been more and more upfront with some requirements:</p>\n<ul>\n<li>I will only build <em>static</em> sites. I don’t want to be building anyone’s custom\nCMS or billing system.</li>\n<li>I will only work with my preferred development workflow: Git / GitHub + Netlify\nand continuous deployment. I’d rather not hand off code in a zip file or\nconfigure anyone’s <em>phpMyAdmin</em> console.</li>\n</ul>\n<p>As long as my friends are OK with my snobby requirements, I’m happy to oblige.\nOne missing piece from this workflow is the ability for people to update the\ncontent after the site has been deployed. Historically the solution to that\nhas either been use a CMS like Wordpress or just update the content manually\neverytime a change is needed. But recently there’s been a surge of tools that\nprovide a new option: use a headless CMS. A headless CMS allows for content\nowners to update the content in a third-party admin console and for me to\npull in that data at build time so I can continue to use my favorite static-site\ntools. One of the new headless CMS options is <a href=\"https://datocms.com\">DatoCMS</a>,\nand I recently had a great experience working with it alongside <a href=\"https://11ty.io\">Eleventy</a>,\nmy current static-site generator of choice. In this post I’ll go through the\nsetup and experience.</p>\n<p>I’ve set up an example respository here if you’d like to skip to the code:\n<a href=\"https://github.com/npbee/Eleventy-DatoCMS-Netlify\">Eleventy-DatoCMS-Netlify</a>.</p>\n<h2 id=\"what-is-a-headless-cms-anyway\">What is a Headless CMS Anyway?</h2>\n<p>First, a quick primer on headless CMS systems. A typical Content Management\nSystem (CMS) loads content from a database and renders that content to a\ntemplate of some sort. Updating the content involves logging into an adminstration\nconsole and changing the content. So in this world,\nthe content, administration, and display logic are all together in one codebase.\nA headless CMS on the other hand, separates the content and adminstration of the\ncontent from the view layer. Data is maintained and updated in one system and\nthe view layer pulls in that data at build time to create the static site. If\nyou’ve ever built a static site that had local data files of some sort, it’s\njust like that except your data files live on a third-party server somewhere.</p>\n<p>There are lots of headless CMS options out there, but for my project I chose\n<a href=\"https://datocms.com\">DatoCMS</a>. The interface was simple, pricing was reasonable,\nand they have a GraphQL API interface, of which I’m a big fan.</p>\n<h2 id=\"the-data-flow\">The Data Flow</h2>\n<p>Since Netlify is the point at which the updated data is fetched from DatoCMS, a\nnew site build can happen either when new site code is pushed to GitHub <em>or</em> when\nthe content is udpated through the Dato admin interface. In the case of data\nupdates, Dato tells Netlify that a new build needs to happen. Netlify then\nstarts the build and asks Dato for the new data.</p>\n<p><img src=\"/posts/dato-1.png\" alt=\"Image describing data flow between Github, DatoCMS, and Netlify\"></p>\n<h2 id=\"fetching-data-from-datocms\">Fetching Data from DatoCMS</h2>\n<p>To actually start building a site, we need to be able to get data from DatoCMS.\nThe example we’ll work with is a restaurant building a menu (which was the\nactual original use case).</p>\n<p>Each headless CMS service will have different details, but fundamentally in each\none you describe how your content is structured by telling the service what\nkind of data you’re working with and what each of the properties are. In DatoCMS,\nthese are “models” and “fields” so you may have a model called “Menu Item”\nthat is made of up of a “name” field that is a string and a “price” field that\nis a number.</p>\n<p><img src=\"/posts/dato-model.png\" alt=\"DatoCMS Model structure\"></p>\n<p>This configuration ties directly to the GraphQL query that you make to DatoCMS:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F97583\">query</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">Site</span><span style=\"color: #E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #FFAB70\">allMenuItems</span><span style=\"color: #E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #FFAB70\">name</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #FFAB70\">price</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">}</span></span></code></pre>\n<p>DatoCMS offers an “API Explorer” on the site which allows you to query your\ndata:</p>\n<p><img src=\"/posts/dato-api-explorer.png\" alt=\"DatoCMS API Explorer\"></p>\n<p>The API Explorer is great because you can tinker with your query until you get\nit just right and then copy the query and paste it into a file in your\ncodebase. This makes for a really nice workflow where updating the data on the\nsite is a matter of pasting in a new query to a file.</p>\n<p>Finally, to actually fetch the data we can use a rather plain <code>fetch</code> call;</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">fetch</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">require</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\"node-fetch\"</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">path</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">require</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\"path\"</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6A737D\">// The DatoCMS token available fro the DatoCMS dashboard</span></span>\n<span class=\"line\"><span style=\"color: #6A737D\">// More on this later...</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">token</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> process\u002Eenv.</span><span style=\"color: #79B8FF\">DATO_API_TOKEN</span><span style=\"color: #E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F97583\">async</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">function</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">fetchData</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #FFAB70\">token</span><span style=\"color: #E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #6A737D\">// Read the query from the file. A bit nicer to work with once the query</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #6A737D\">// gets bigger. You can also copy and paste directly from the Dato API</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #6A737D\">// explorer into the file.</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">query</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">await</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">readFile</span><span style=\"color: #E1E4E8\">(path.</span><span style=\"color: #B392F0\">join</span><span style=\"color: #E1E4E8\">(__dirname, </span><span style=\"color: #9ECBFF\">\"query.graphql\"</span><span style=\"color: #E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">response</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">await</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">fetch</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\"https://graphql.datocms.com/\"</span><span style=\"color: #E1E4E8\">, {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    method: </span><span style=\"color: #9ECBFF\">\"POST\"</span><span style=\"color: #E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    headers: {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      </span><span style=\"color: #9ECBFF\">\"Content-Type\"</span><span style=\"color: #E1E4E8\">: </span><span style=\"color: #9ECBFF\">\"application/json\"</span><span style=\"color: #E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      Accept: </span><span style=\"color: #9ECBFF\">\"application/json\"</span><span style=\"color: #E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      Authorization: </span><span style=\"color: #9ECBFF\">`Bearer ${</span><span style=\"color: #E1E4E8\">token</span><span style=\"color: #9ECBFF\">}`</span><span style=\"color: #E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    body: </span><span style=\"color: #79B8FF\">JSON</span><span style=\"color: #E1E4E8\">.</span><span style=\"color: #B392F0\">stringify</span><span style=\"color: #E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      query: query.</span><span style=\"color: #B392F0\">toString</span><span style=\"color: #E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    }),</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  }).</span><span style=\"color: #B392F0\">then</span><span style=\"color: #E1E4E8\">((</span><span style=\"color: #FFAB70\">res</span><span style=\"color: #E1E4E8\">) </span><span style=\"color: #F97583\">=></span><span style=\"color: #E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">if</span><span style=\"color: #E1E4E8\"> (res.ok) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      </span><span style=\"color: #F97583\">return</span><span style=\"color: #E1E4E8\"> res.</span><span style=\"color: #B392F0\">json</span><span style=\"color: #E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    } </span><span style=\"color: #F97583\">else</span><span style=\"color: #E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      </span><span style=\"color: #F97583\">throw</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">new</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">Error</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\"Aborting: DatoCMS request failed with \"</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">+</span><span style=\"color: #E1E4E8\"> res.status);</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">if</span><span style=\"color: #E1E4E8\"> (response.errors) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">for</span><span style=\"color: #E1E4E8\"> (</span><span style=\"color: #F97583\">let</span><span style=\"color: #E1E4E8\"> error </span><span style=\"color: #F97583\">of</span><span style=\"color: #E1E4E8\"> response.errors) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      console.</span><span style=\"color: #B392F0\">error</span><span style=\"color: #E1E4E8\">(error.message);</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">throw</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">new</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">Error</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\"Aborting: DatoCMS errors\"</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  } </span><span style=\"color: #F97583\">else</span><span style=\"color: #E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">return</span><span style=\"color: #E1E4E8\"> response.data;</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">}</span></span></code></pre>\n<p>As you can see above, we need a token from DatoCMS in order have the authorization\nnecessary to query our site. This is secret, so it lives in an environment\nvariable. For development, that means doing something like setting the\nvariable with in a <code>.env</code> file and using something like <a href=\"https://github.com/motdotla/dotenv\"><code>dotenv</code></a> to pull in the variables. In production, we’ll have to set the\nvariable within the Netlify dashboard. More on that soon.</p>\n<h2 id=\"fetching-data-with-eleventy\">Fetching Data with Eleventy</h2>\n<p>Above we showed how to fetch data from DatoCMS using a <code>fetch</code> call, but how\ndoes that work with Eleventy? The answer is Eleventy’s <a href=\"https://www.11ty.dev/docs/data-js/\">JS data files</a>. With JS data files, you can use JS to do anything you need\nto do to get your data, including making a network call. By placing a\nfile within the special <code>_data</code> directory, Eleventy will expose whatever you\nreturn to your template files:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A737D\">// _data/cms.js</span></span>\n<span class=\"line\"><span style=\"color: #79B8FF\">module</span><span style=\"color: #E1E4E8\">.</span><span style=\"color: #79B8FF\">exports</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">async</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">function</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">Cms</span><span style=\"color: #E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">token</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> process\u002Eenv.</span><span style=\"color: #79B8FF\">DATO_API_TOKEN</span><span style=\"color: #E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">cachePath</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> path.</span><span style=\"color: #B392F0\">join</span><span style=\"color: #E1E4E8\">(__dirname, </span><span style=\"color: #9ECBFF\">\"cms.cache.json\"</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">return</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">await</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">fetchData</span><span style=\"color: #E1E4E8\">(token);</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">};</span></span></code></pre>\n<p>Then in your templates:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A737D\">&#x3C;!-- `cms` because that's what we named the file in the `_data` directory --></span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">{% for item in cms.allMenuItems %}</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">&#x3C;</span><span style=\"color: #85E89D\">p</span><span style=\"color: #E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  &#x3C;</span><span style=\"color: #85E89D\">strong</span><span style=\"color: #E1E4E8\">>Name&#x3C;/</span><span style=\"color: #85E89D\">strong</span><span style=\"color: #E1E4E8\">> {{ item.name }} &#x3C;</span><span style=\"color: #85E89D\">strong</span><span style=\"color: #E1E4E8\">>Price&#x3C;/</span><span style=\"color: #85E89D\">strong</span><span style=\"color: #E1E4E8\">> {{ item.price }}</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">&#x3C;/</span><span style=\"color: #85E89D\">p</span><span style=\"color: #E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">{% endfor %}</span></span></code></pre>\n<p>That’s it! We now have an Eleventy site fetching data from DatoCMS and building a\nstatic site.</p>\n<h2 id=\"caching-data\">Caching Data</h2>\n<p>The current setup works, but you may see this in your console output:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #E1E4E8\">Writing _site</span><span style=\"color: #F97583\">/</span><span style=\"color: #E1E4E8\">index.html from .</span><span style=\"color: #F97583\">/</span><span style=\"color: #E1E4E8\">index.njk.</span></span>\n<span class=\"line\"><span style=\"color: #B392F0\">Benchmark</span><span style=\"color: #E1E4E8\"> (Data): </span><span style=\"color: #9ECBFF\">`./_data/cms.js`</span><span style=\"color: #E1E4E8\"> took 581</span><span style=\"color: #B392F0\">ms</span><span style=\"color: #E1E4E8\"> (</span><span style=\"color: #79B8FF\">66.0</span><span style=\"color: #F97583\">%</span><span style=\"color: #E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">Processed </span><span style=\"color: #79B8FF\">2</span><span style=\"color: #E1E4E8\"> files </span><span style=\"color: #F97583\">in</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">0.82</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">seconds</span><span style=\"color: #E1E4E8\"> (v0.</span><span style=\"color: #79B8FF\">9.0</span><span style=\"color: #E1E4E8\">)</span></span></code></pre>\n<p>Eleventy is noting that it took a noticeable amount of time to to handle our\n<code>_data/cms.js</code> file. We can avoid going over the network each time by writing the DatoCMS response\nto a file and using that file if it exists:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> { </span><span style=\"color: #79B8FF\">promisify</span><span style=\"color: #E1E4E8\"> } </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">require</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\"util\"</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">path</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">require</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\"path\"</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">fs</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">require</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\"fs\"</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">writeFile</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">promisify</span><span style=\"color: #E1E4E8\">(fs.writeFile);</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">readFile</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">promisify</span><span style=\"color: #E1E4E8\">(fs.readFile);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #79B8FF\">module</span><span style=\"color: #E1E4E8\">.</span><span style=\"color: #79B8FF\">exports</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">async</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">function</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">Cms</span><span style=\"color: #E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">token</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> process\u002Eenv.</span><span style=\"color: #79B8FF\">DATO_API_TOKEN</span><span style=\"color: #E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">cachePath</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> path.</span><span style=\"color: #B392F0\">join</span><span style=\"color: #E1E4E8\">(__dirname, </span><span style=\"color: #9ECBFF\">\"cms.cache.json\"</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">cache</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">await</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">getCache</span><span style=\"color: #E1E4E8\">(cachePath);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">if</span><span style=\"color: #E1E4E8\"> (cache) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    console.</span><span style=\"color: #B392F0\">log</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\">> Using cached data\"</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">return</span><span style=\"color: #E1E4E8\"> cache;</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  } </span><span style=\"color: #F97583\">else</span><span style=\"color: #E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    console.</span><span style=\"color: #B392F0\">log</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\">> Fetching data from DatoCMS\"</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">data</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">await</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">fetchData</span><span style=\"color: #E1E4E8\">(token);</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">await</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">writeFile</span><span style=\"color: #E1E4E8\">(cachePath, </span><span style=\"color: #79B8FF\">JSON</span><span style=\"color: #E1E4E8\">.</span><span style=\"color: #B392F0\">stringify</span><span style=\"color: #E1E4E8\">(data, </span><span style=\"color: #79B8FF\">null</span><span style=\"color: #E1E4E8\">, </span><span style=\"color: #79B8FF\">2</span><span style=\"color: #E1E4E8\">));</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">return</span><span style=\"color: #E1E4E8\"> data;</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F97583\">async</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">function</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">getCache</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #FFAB70\">cachePath</span><span style=\"color: #E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">try</span><span style=\"color: #E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">cache</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">await</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">readFile</span><span style=\"color: #E1E4E8\">(cachePath);</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">return</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">JSON</span><span style=\"color: #E1E4E8\">.</span><span style=\"color: #B392F0\">parse</span><span style=\"color: #E1E4E8\">(cache);</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  } </span><span style=\"color: #F97583\">catch</span><span style=\"color: #E1E4E8\"> (err) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #6A737D\">// If this fails, that means there is no cache. Return `undefined` to</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #6A737D\">// fetch from the network</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">}</span></span></code></pre>\n<p>Make sure ignore the cache file in the <code>.gitignore</code> file:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A737D\"># Cached data</span></span>\n<span class=\"line\"><span style=\"color: #B392F0\">_data/cms.cache.json</span></span></code></pre>\n<p>This will only fetch fresh data if the <code>_data/cms.cache.json</code> does not exist.\nIn development, this is usually preferrable as your developing the site as you\nprobably don’t need to fetch new data every time. In production, there will\nnever be any cache so we’ll always fetch fresh data.</p>\n<h2 id=\"deployment\">Deployment</h2>\n<p>Assuming you have Netlify and GitHub integrated, the only missing piece for\nbeing able to deploy our site is telling Netlify what our DatoCMS token is.\nThis is easily done via the Netlify admin dashboard:</p>\n<p><img src=\"/posts/dato-netlify-token.png\" alt=\"DatoCMS token in Netlify dashboard\"></p>\n<p>Once that is in place, pushing new code to GitHub will trigger a build in Netlify,\nwhich will fetch fresh data from DatoCMS!</p>\n<h2 id=\"integrating-datocms-with-netlify\">Integrating DatoCMS with Netlify</h2>\n<p>Almost done! The only missing piece left is to be able to deploy a new version\nof our site whenever the data content changes. To do that, we need to a\n“Deployment Environment” in DatoCMS. A deployment environment in Dato is how you\nconfigure DatoCMS to re-build your site based on the services you’re using.\nAfter you’ve set up a deployment environment, you’ll see these notifications\nin the top right:</p>\n<p><img src=\"/posts/dato-up-to-date.png\" alt=\"DatoCMS deployment environment status displaying &#x22;Up to date&#x22;\">\n<img src=\"/posts/dato-out-of-date.png\" alt=\"DatoCMS deployment environment status displaying &#x22;Out of date&#x22;\">\n<img src=\"/posts/dato-in-progress.png\" alt=\"DatoCMS deployment environment status displaying &#x22;In progress&#x22;\"></p>\n<p>DatoCMS has a great integration with Netlify that essentially makes this a one-click\nsetup. You authorize DatoCMS to your Netlify site, and it will more-or-less\ndo the rest. That said, I actually had some issues with that because at the\ntime it seemed that outgoing webhooks were not allowed on the free plan of\nNetlify. This meant that I could trigger a build from DatoCMS, but Dato would\nnever be notified of the status of the build. This looks to not be an issue\nanymore so if the integration works for you, then you should use it! Regardless,\nI thought it would be interesting to see how to set up a custom deployment\nenvironment using Netlify functions.</p>\n<h3 id=\"custom-deployment-environment-with-netlify-functions\">Custom Deployment Environment with Netlify Functions</h3>\n<p>At the end of the day, communication between services is usually just each\nservice sending <code>POST</code> requests to each other. By utilizing Netlify’s <a href=\"https://docs.netlify.com/functions/trigger-on-events/\">functions\nand event triggers</a>, we\ncan set up our own custom deployment environment.</p>\n<p>First, we need to set up a build hook in Netlify:</p>\n<p><img src=\"/posts/dato-build-hook.png\" alt=\"Netlify build hook\"></p>\n<p>This is the URL that we want DatoCMS to <code>POST</code> whenever it wants to trigger a\nnew build.</p>\n<p>Then, within DatoCMS, choose “Custom webhook” to set up the custom deployment\nenvironment:</p>\n<p><img src=\"/posts/dato-custom-webhook.png\" alt=\"DatoCMS custom webhook\"></p>\n<p>Paste in the build hook from Netlify in the “Trigger URL” input. In the “Status notifications”\nsection, Dato is displaying the information that we need to send <em>back</em> to\nDato from Netlify when the builds are complete. This is how Dato knows what\nhappened from Netlify. We’ll need to create a new environment variable in\nNetlify with this info:</p>\n<p><img src=\"/posts/dato-status-url.png\" alt=\"Netlify status URL environment variable\"></p>\n<p>Lastly, we need to create two new functions: one named <code>deploy-succeeded.js</code>\nand one named <code>deploy-failed.js</code>. The names are significant as they indicate\nto Netlify that these are functions to be triggered when those specific\ndeploy events happened. In a <code>functions</code> folder:</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #6A737D\">// functions/deploy-succeeded.js</span></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">fetch</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">require</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">\"node-fetch\"</span><span style=\"color: #E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> { </span><span style=\"color: #79B8FF\">DATO_STATUS_URL</span><span style=\"color: #E1E4E8\"> } </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> process\u002Eenv;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F97583\">const</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">data</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">JSON</span><span style=\"color: #E1E4E8\">.</span><span style=\"color: #B392F0\">stringify</span><span style=\"color: #E1E4E8\">({ status: </span><span style=\"color: #9ECBFF\">\"success\"</span><span style=\"color: #E1E4E8\"> });</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #79B8FF\">exports</span><span style=\"color: #E1E4E8\">.</span><span style=\"color: #B392F0\">handler</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">async</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">function</span><span style=\"color: #E1E4E8\"> (</span><span style=\"color: #FFAB70\">_event</span><span style=\"color: #E1E4E8\">, </span><span style=\"color: #FFAB70\">_context</span><span style=\"color: #E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">let</span><span style=\"color: #E1E4E8\"> response;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">try</span><span style=\"color: #E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    response </span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">await</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">fetch</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #79B8FF\">DATO_STATUS_URL</span><span style=\"color: #E1E4E8\">, {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      method: </span><span style=\"color: #9ECBFF\">\"POST\"</span><span style=\"color: #E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      headers: {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">        </span><span style=\"color: #9ECBFF\">\"Content-Type\"</span><span style=\"color: #E1E4E8\">: </span><span style=\"color: #9ECBFF\">\"application/json\"</span><span style=\"color: #E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      },</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      body: data,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    });</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  } </span><span style=\"color: #F97583\">catch</span><span style=\"color: #E1E4E8\"> (err) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">return</span><span style=\"color: #E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      statusCode: err.statusCode </span><span style=\"color: #F97583\">||</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #79B8FF\">500</span><span style=\"color: #E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      body: </span><span style=\"color: #79B8FF\">JSON</span><span style=\"color: #E1E4E8\">.</span><span style=\"color: #B392F0\">stringify</span><span style=\"color: #E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">        error: err.message,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      }),</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    };</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">return</span><span style=\"color: #E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    statusCode: </span><span style=\"color: #79B8FF\">200</span><span style=\"color: #E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    body: </span><span style=\"color: #79B8FF\">JSON</span><span style=\"color: #E1E4E8\">.</span><span style=\"color: #B392F0\">stringify</span><span style=\"color: #E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      data: response,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    }),</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  };</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">};</span></span></code></pre>\n<p>I’ll leave the <code>deploy-failed.js</code> out, but it’s pretty much the same except\nwith a different payload.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Phew! After typing all of this out, I can definitely see how this type of\nsetup may seem overly complicated and you may be thinking that you might as\nwell just deploy a Wordpress site. In my case, I highly value a workflow that\nallows me to iterate fast and also minimizes my overall maintenance cost.\nStatic sites are extremely low maintenance since there are no databases or\nservers to deal with.</p>\n<p>I can say that this set up has been running smoothly for months now and my\nfriends love their new CMS setup. They previously <em>had</em> a custom Wordpress\nsite built for them by someone who had since abandoned them, leaving them\nwith an out-of-date Wordpress deployment and a pretty horrible editing experience.\nIf you enjoy building static site and want to extend your offering to allow\nfor dynamic content, I highly recommend giving this setup a try!</p>");

				const frontmatter = {"title":"Eleventy + DatoCMS + Netlify","date":"2019-12-21T00:00:00.000Z","description":"Building a static site with a headless CMS"};
				const file = "/Users/nickball/code/npb/src/content/blog/eleventy-datocms-netlify.md";
				const url = undefined;
				function rawContent() {
					return "\nAs a web developer I get the occasional ask from friends to help them build a\nwebsite. I generally don't mind and am happy to help out my buddies, but lately\nas I've been limited on spare time, I've been more and more upfront with some requirements:\n\n- I will only build _static_ sites. I don't want to be building anyone's custom\n  CMS or billing system.\n- I will only work with my preferred development workflow: Git / GitHub + Netlify\n  and continuous deployment. I'd rather not hand off code in a zip file or\n  configure anyone's _phpMyAdmin_ console.\n\nAs long as my friends are OK with my snobby requirements, I'm happy to oblige.\nOne missing piece from this workflow is the ability for people to update the\ncontent after the site has been deployed. Historically the solution to that\nhas either been use a CMS like Wordpress or just update the content manually\neverytime a change is needed. But recently there's been a surge of tools that\nprovide a new option: use a headless CMS. A headless CMS allows for content\nowners to update the content in a third-party admin console and for me to\npull in that data at build time so I can continue to use my favorite static-site\ntools. One of the new headless CMS options is [DatoCMS](https://datocms.com),\nand I recently had a great experience working with it alongside [Eleventy](https://11ty.io),\nmy current static-site generator of choice. In this post I'll go through the\nsetup and experience.\n\nI've set up an example respository here if you'd like to skip to the code:\n[Eleventy-DatoCMS-Netlify](https://github.com/npbee/Eleventy-DatoCMS-Netlify).\n\n## What is a Headless CMS Anyway?\n\nFirst, a quick primer on headless CMS systems. A typical Content Management\nSystem (CMS) loads content from a database and renders that content to a\ntemplate of some sort. Updating the content involves logging into an adminstration\nconsole and changing the content. So in this world,\nthe content, administration, and display logic are all together in one codebase.\nA headless CMS on the other hand, separates the content and adminstration of the\ncontent from the view layer. Data is maintained and updated in one system and\nthe view layer pulls in that data at build time to create the static site. If\nyou've ever built a static site that had local data files of some sort, it's\njust like that except your data files live on a third-party server somewhere.\n\nThere are lots of headless CMS options out there, but for my project I chose\n[DatoCMS](https://datocms.com). The interface was simple, pricing was reasonable,\nand they have a GraphQL API interface, of which I'm a big fan.\n\n## The Data Flow\n\nSince Netlify is the point at which the updated data is fetched from DatoCMS, a\nnew site build can happen either when new site code is pushed to GitHub _or_ when\nthe content is udpated through the Dato admin interface. In the case of data\nupdates, Dato tells Netlify that a new build needs to happen. Netlify then\nstarts the build and asks Dato for the new data.\n\n![Image describing data flow between Github, DatoCMS, and Netlify](/posts/dato-1.png)\n\n## Fetching Data from DatoCMS\n\nTo actually start building a site, we need to be able to get data from DatoCMS.\nThe example we'll work with is a restaurant building a menu (which was the\nactual original use case).\n\nEach headless CMS service will have different details, but fundamentally in each\none you describe how your content is structured by telling the service what\nkind of data you're working with and what each of the properties are. In DatoCMS,\nthese are \"models\" and \"fields\" so you may have a model called \"Menu Item\"\nthat is made of up of a \"name\" field that is a string and a \"price\" field that\nis a number.\n\n![DatoCMS Model structure](/posts/dato-model.png)\n\nThis configuration ties directly to the GraphQL query that you make to DatoCMS:\n\n```graphql\nquery Site {\n  allMenuItems {\n    name\n    price\n  }\n}\n```\n\nDatoCMS offers an \"API Explorer\" on the site which allows you to query your\ndata:\n\n![DatoCMS API Explorer](/posts/dato-api-explorer.png)\n\nThe API Explorer is great because you can tinker with your query until you get\nit just right and then copy the query and paste it into a file in your\ncodebase. This makes for a really nice workflow where updating the data on the\nsite is a matter of pasting in a new query to a file.\n\nFinally, to actually fetch the data we can use a rather plain `fetch` call;\n\n```js\nconst fetch = require(\"node-fetch\");\nconst path = require(\"path\");\n\n// The DatoCMS token available fro the DatoCMS dashboard\n// More on this later...\nconst token = process\u002Eenv.DATO_API_TOKEN;\n\nasync function fetchData(token) {\n  // Read the query from the file. A bit nicer to work with once the query\n  // gets bigger. You can also copy and paste directly from the Dato API\n  // explorer into the file.\n  const query = await readFile(path.join(__dirname, \"query.graphql\"));\n  const response = await fetch(\"https://graphql.datocms.com/\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\",\n      Authorization: `Bearer ${token}`,\n    },\n    body: JSON.stringify({\n      query: query.toString(),\n    }),\n  }).then((res) => {\n    if (res.ok) {\n      return res.json();\n    } else {\n      throw new Error(\"Aborting: DatoCMS request failed with \" + res.status);\n    }\n  });\n\n  if (response.errors) {\n    for (let error of response.errors) {\n      console.error(error.message);\n    }\n    throw new Error(\"Aborting: DatoCMS errors\");\n  } else {\n    return response.data;\n  }\n}\n```\n\nAs you can see above, we need a token from DatoCMS in order have the authorization\nnecessary to query our site. This is secret, so it lives in an environment\nvariable. For development, that means doing something like setting the\nvariable with in a `.env` file and using something like [`dotenv`](https://github.com/motdotla/dotenv) to pull in the variables. In production, we'll have to set the\nvariable within the Netlify dashboard. More on that soon.\n\n## Fetching Data with Eleventy\n\nAbove we showed how to fetch data from DatoCMS using a `fetch` call, but how\ndoes that work with Eleventy? The answer is Eleventy's [JS data files](https://www.11ty.dev/docs/data-js/). With JS data files, you can use JS to do anything you need\nto do to get your data, including making a network call. By placing a\nfile within the special `_data` directory, Eleventy will expose whatever you\nreturn to your template files:\n\n```js\n// _data/cms.js\nmodule.exports = async function Cms() {\n  const token = process\u002Eenv.DATO_API_TOKEN;\n  const cachePath = path.join(__dirname, \"cms.cache.json\");\n  return await fetchData(token);\n};\n```\n\nThen in your templates:\n\n```html\n<!-- `cms` because that's what we named the file in the `_data` directory -->\n{% for item in cms.allMenuItems %}\n<p>\n  <strong>Name</strong> {{ item.name }} <strong>Price</strong> {{ item.price }}\n</p>\n{% endfor %}\n```\n\nThat's it! We now have an Eleventy site fetching data from DatoCMS and building a\nstatic site.\n\n## Caching Data\n\nThe current setup works, but you may see this in your console output:\n\n```js\nWriting _site/index.html from ./index.njk.\nBenchmark (Data): `./_data/cms.js` took 581ms (66.0%)\nProcessed 2 files in 0.82 seconds (v0.9.0)\n```\n\nEleventy is noting that it took a noticeable amount of time to to handle our\n`_data/cms.js` file. We can avoid going over the network each time by writing the DatoCMS response\nto a file and using that file if it exists:\n\n```js\nconst { promisify } = require(\"util\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\n\nconst writeFile = promisify(fs.writeFile);\nconst readFile = promisify(fs.readFile);\n\nmodule.exports = async function Cms() {\n  const token = process\u002Eenv.DATO_API_TOKEN;\n  const cachePath = path.join(__dirname, \"cms.cache.json\");\n  const cache = await getCache(cachePath);\n\n  if (cache) {\n    console.log(\">> Using cached data\");\n    return cache;\n  } else {\n    console.log(\">> Fetching data from DatoCMS\");\n    const data = await fetchData(token);\n    await writeFile(cachePath, JSON.stringify(data, null, 2));\n    return data;\n  }\n};\n\nasync function getCache(cachePath) {\n  try {\n    const cache = await readFile(cachePath);\n    return JSON.parse(cache);\n  } catch (err) {\n    // If this fails, that means there is no cache. Return `undefined` to\n    // fetch from the network\n  }\n}\n```\n\nMake sure ignore the cache file in the `.gitignore` file:\n\n```bash\n# Cached data\n_data/cms.cache.json\n```\n\nThis will only fetch fresh data if the `_data/cms.cache.json` does not exist.\nIn development, this is usually preferrable as your developing the site as you\nprobably don't need to fetch new data every time. In production, there will\nnever be any cache so we'll always fetch fresh data.\n\n## Deployment\n\nAssuming you have Netlify and GitHub integrated, the only missing piece for\nbeing able to deploy our site is telling Netlify what our DatoCMS token is.\nThis is easily done via the Netlify admin dashboard:\n\n![DatoCMS token in Netlify dashboard](/posts/dato-netlify-token.png)\n\nOnce that is in place, pushing new code to GitHub will trigger a build in Netlify,\nwhich will fetch fresh data from DatoCMS!\n\n## Integrating DatoCMS with Netlify\n\nAlmost done! The only missing piece left is to be able to deploy a new version\nof our site whenever the data content changes. To do that, we need to a\n\"Deployment Environment\" in DatoCMS. A deployment environment in Dato is how you\nconfigure DatoCMS to re-build your site based on the services you're using.\nAfter you've set up a deployment environment, you'll see these notifications\nin the top right:\n\n![DatoCMS deployment environment status displaying \"Up to date\"](/posts/dato-up-to-date.png)\n![DatoCMS deployment environment status displaying \"Out of date\"](/posts/dato-out-of-date.png)\n![DatoCMS deployment environment status displaying \"In progress\"](/posts/dato-in-progress.png)\n\nDatoCMS has a great integration with Netlify that essentially makes this a one-click\nsetup. You authorize DatoCMS to your Netlify site, and it will more-or-less\ndo the rest. That said, I actually had some issues with that because at the\ntime it seemed that outgoing webhooks were not allowed on the free plan of\nNetlify. This meant that I could trigger a build from DatoCMS, but Dato would\nnever be notified of the status of the build. This looks to not be an issue\nanymore so if the integration works for you, then you should use it! Regardless,\nI thought it would be interesting to see how to set up a custom deployment\nenvironment using Netlify functions.\n\n### Custom Deployment Environment with Netlify Functions\n\nAt the end of the day, communication between services is usually just each\nservice sending `POST` requests to each other. By utilizing Netlify's [functions\nand event triggers](https://docs.netlify.com/functions/trigger-on-events/), we\ncan set up our own custom deployment environment.\n\nFirst, we need to set up a build hook in Netlify:\n\n![Netlify build hook](/posts/dato-build-hook.png)\n\nThis is the URL that we want DatoCMS to `POST` whenever it wants to trigger a\nnew build.\n\nThen, within DatoCMS, choose \"Custom webhook\" to set up the custom deployment\nenvironment:\n\n![DatoCMS custom webhook](/posts/dato-custom-webhook.png)\n\nPaste in the build hook from Netlify in the \"Trigger URL\" input. In the \"Status notifications\"\nsection, Dato is displaying the information that we need to send _back_ to\nDato from Netlify when the builds are complete. This is how Dato knows what\nhappened from Netlify. We'll need to create a new environment variable in\nNetlify with this info:\n\n![Netlify status URL environment variable](/posts/dato-status-url.png)\n\nLastly, we need to create two new functions: one named `deploy-succeeded.js`\nand one named `deploy-failed.js`. The names are significant as they indicate\nto Netlify that these are functions to be triggered when those specific\ndeploy events happened. In a `functions` folder:\n\n```js\n// functions/deploy-succeeded.js\nconst fetch = require(\"node-fetch\");\n\nconst { DATO_STATUS_URL } = process\u002Eenv;\n\nconst data = JSON.stringify({ status: \"success\" });\n\nexports.handler = async function (_event, _context) {\n  let response;\n\n  try {\n    response = await fetch(DATO_STATUS_URL, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: data,\n    });\n  } catch (err) {\n    return {\n      statusCode: err.statusCode || 500,\n      body: JSON.stringify({\n        error: err.message,\n      }),\n    };\n  }\n\n  return {\n    statusCode: 200,\n    body: JSON.stringify({\n      data: response,\n    }),\n  };\n};\n```\n\nI'll leave the `deploy-failed.js` out, but it's pretty much the same except\nwith a different payload.\n\n## Conclusion\n\nPhew! After typing all of this out, I can definitely see how this type of\nsetup may seem overly complicated and you may be thinking that you might as\nwell just deploy a Wordpress site. In my case, I highly value a workflow that\nallows me to iterate fast and also minimizes my overall maintenance cost.\nStatic sites are extremely low maintenance since there are no databases or\nservers to deal with.\n\nI can say that this set up has been running smoothly for months now and my\nfriends love their new CMS setup. They previously _had_ a custom Wordpress\nsite built for them by someone who had since abandoned them, leaving them\nwith an out-of-date Wordpress deployment and a pretty horrible editing experience.\nIf you enjoy building static site and want to extend your offering to allow\nfor dynamic content, I highly recommend giving this setup a try!\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"what-is-a-headless-cms-anyway","text":"What is a Headless CMS Anyway?"},{"depth":2,"slug":"the-data-flow","text":"The Data Flow"},{"depth":2,"slug":"fetching-data-from-datocms","text":"Fetching Data from DatoCMS"},{"depth":2,"slug":"fetching-data-with-eleventy","text":"Fetching Data with Eleventy"},{"depth":2,"slug":"caching-data","text":"Caching Data"},{"depth":2,"slug":"deployment","text":"Deployment"},{"depth":2,"slug":"integrating-datocms-with-netlify","text":"Integrating DatoCMS with Netlify"},{"depth":3,"slug":"custom-deployment-environment-with-netlify-functions","text":"Custom Deployment Environment with Netlify Functions"},{"depth":2,"slug":"conclusion","text":"Conclusion"}];
				}
				async function Content() {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;
					const contentFragment = createVNode(Fragment, { 'set:html': html });
					return contentFragment;
				}
				Content[Symbol.for('astro.needsHeadRendering')] = true;

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, images, rawContent, url };
