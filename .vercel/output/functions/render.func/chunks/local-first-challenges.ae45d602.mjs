import { j as createVNode, F as Fragment, k as spreadAttributes } from './astro.c61b1d12.mjs';
import 'cookie';
import 'kleur/colors';
import 'path-to-regexp';
import 'mime';
import 'string-width';
import 'html-escaper';

const images = {
					
				};

				function updateImageReferences(html) {
					return html.replaceAll(
						/__ASTRO_IMAGE_="([^"]+)"/gm,
						(full, imagePath) => spreadAttributes({src: images[imagePath].src, ...images[imagePath].attributes})
					);
				}

				const html = updateImageReferences("<p>Recently I’ve been getting excited about <a href=\"https://www.inkandswitch.com/local-first/\">local-first</a> applications so I thought I would try my hand at building one.\nThe app will be a personal songwriting tool for organizing, versioning, and making notes on in-progress songs. Sort of a personal Soundcloud app of sorts.\nI think I’ve finally settled on a decent architecture, but the process has forced me to rethink some of my go-to patterns that I use to build on cloud-based software.</p>\n<h2 id=\"am-i-the-client-or-the-server\">Am I the Client or the Server?</h2>\n<p>In my normal day-to-day work I’m almost always writing code for the <em>client</em>.\nYou want data? Make an HTTP request from the <em>server</em> to get it.\nYou need a file? Make an HTTP request from the <em>server</em>.\nIn a local-first app those boundaries aren’t as clear.\nI can write a SQL query right next to my React component!</p>\n<pre is:raw=\"\" class=\"astro-code github-dark\" style=\"background-color: #24292e; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #F97583\">function</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">SomeComponent</span><span style=\"color: #E1E4E8\">({ </span><span style=\"color: #FFAB70\">db</span><span style=\"color: #E1E4E8\">, </span><span style=\"color: #FFAB70\">id</span><span style=\"color: #E1E4E8\"> }) {</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #F97583\">async</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">function</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">updateName</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #FFAB70\">name</span><span style=\"color: #E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    </span><span style=\"color: #F97583\">await</span><span style=\"color: #E1E4E8\"> db.</span><span style=\"color: #B392F0\">execute</span><span style=\"color: #E1E4E8\">(</span><span style=\"color: #9ECBFF\">`</span></span>\n<span class=\"line\"><span style=\"color: #9ECBFF\">      UPDATE songs</span></span>\n<span class=\"line\"><span style=\"color: #9ECBFF\">      SET name = ?</span></span>\n<span class=\"line\"><span style=\"color: #9ECBFF\">      WHERE id = ?</span></span>\n<span class=\"line\"><span style=\"color: #9ECBFF\">    `</span><span style=\"color: #E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    [name, id]</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  </span><span style=\"color: #B392F0\">return</span><span style=\"color: #E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    &#x3C;</span><span style=\"color: #85E89D\">input</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">      </span><span style=\"color: #B392F0\">onChange</span><span style=\"color: #F97583\">=</span><span style=\"color: #E1E4E8\">{</span><span style=\"color: #FFAB70\">evt</span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #F97583\">=></span><span style=\"color: #E1E4E8\"> </span><span style=\"color: #B392F0\">updateName</span><span style=\"color: #E1E4E8\">(evt.target.value)}</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">    /></span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">  );</span></span>\n<span class=\"line\"><span style=\"color: #E1E4E8\">}</span></span></code></pre>\n<h2 id=\"storage-also-syncing-and-undoredo-oh-also-searching\">Storage? Also Syncing. And undo/redo. Oh also searching?</h2>\n<p>So far I’ve found it challenging to get all of these features out of the box.\nLike anything in software, the architecture needs to be based on the needs of the application.\nOne of the best parts about local-first apps is that your data is truly local.\nBut that also means that if you <em>want</em> that data to be available elsewhere (like on a phone perhaps), then you have to figure out how to sync the data.\nAdditionally, if you want multiple people to interact with that data you need to think about merging and conflict resolution.\nTying in undo/redo into syncing and conflict resolution makes all of that a <em>hard</em> application to build.</p>\n<p>The rage right now for local-first apps is <a href=\"https://crdt.tech/\">CRDTs</a>.\nI’m still wrapping my head around it, but I understand enough to know that I don’t want to build this myself.\nThere are a couple of libraries out there that do this like <a href=\"https://automerge.org/\">Automerge</a> and <a href=\"https://yjs.dev/\">Y.js</a>.\nY.js in particular seems pretty darn good as it has syncing and undo/redo out of the box.</p>\n<p>The last challenge that relates here is searching.\nFor a local-first app, it feels strange to <em>not</em> choose SQLite since it can easily and efficiently search and query.\nUsing a CRDT library feels like it forces data into a document-based storage format which conflicts a little with how one might typically structure a SQLite database.</p>\n<p>Can you have a CRDT data structure that supports undo/redo and store that in SQLite?\nProbably, but I haven’t figured it out yet.</p>");

				const frontmatter = {"title":"Challenges of a Local-first App","date":"2022-07-16T00:00:00.000Z","description":"Blurring the lines of client and server"};
				const file = "/Users/nickball/code/npb/src/content/blog/local-first-challenges.md";
				const url = undefined;
				function rawContent() {
					return "\nRecently I've been getting excited about [local-first](https://www.inkandswitch.com/local-first/) applications so I thought I would try my hand at building one.\nThe app will be a personal songwriting tool for organizing, versioning, and making notes on in-progress songs. Sort of a personal Soundcloud app of sorts.\nI think I've finally settled on a decent architecture, but the process has forced me to rethink some of my go-to patterns that I use to build on cloud-based software.\n\n## Am I the Client or the Server?\n\nIn my normal day-to-day work I'm almost always writing code for the _client_.\nYou want data? Make an HTTP request from the _server_ to get it.\nYou need a file? Make an HTTP request from the _server_.\nIn a local-first app those boundaries aren't as clear.\nI can write a SQL query right next to my React component!\n\n```tsx\nfunction SomeComponent({ db, id }) {\n\n  async function updateName(name) {\n    await db.execute(`\n      UPDATE songs\n      SET name = ?\n      WHERE id = ?\n    `,\n    [name, id]\n  }\n\n  return (\n    <input\n      onChange={evt => updateName(evt.target.value)}\n    />\n  );\n}\n```\n\n## Storage? Also Syncing. And undo/redo. Oh also searching?\n\nSo far I've found it challenging to get all of these features out of the box.\nLike anything in software, the architecture needs to be based on the needs of the application.\nOne of the best parts about local-first apps is that your data is truly local.\nBut that also means that if you _want_ that data to be available elsewhere (like on a phone perhaps), then you have to figure out how to sync the data.\nAdditionally, if you want multiple people to interact with that data you need to think about merging and conflict resolution.\nTying in undo/redo into syncing and conflict resolution makes all of that a _hard_ application to build.\n\nThe rage right now for local-first apps is [CRDTs](https://crdt.tech/).\nI'm still wrapping my head around it, but I understand enough to know that I don't want to build this myself.\nThere are a couple of libraries out there that do this like [Automerge](https://automerge.org/) and [Y.js](https://yjs.dev/).\nY.js in particular seems pretty darn good as it has syncing and undo/redo out of the box.\n\nThe last challenge that relates here is searching.\nFor a local-first app, it feels strange to _not_ choose SQLite since it can easily and efficiently search and query.\nUsing a CRDT library feels like it forces data into a document-based storage format which conflicts a little with how one might typically structure a SQLite database.\n\nCan you have a CRDT data structure that supports undo/redo and store that in SQLite?\nProbably, but I haven't figured it out yet.\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"am-i-the-client-or-the-server","text":"Am I the Client or the Server?"},{"depth":2,"slug":"storage-also-syncing-and-undoredo-oh-also-searching","text":"Storage? Also Syncing. And undo/redo. Oh also searching?"}];
				}
				async function Content() {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;
					const contentFragment = createVNode(Fragment, { 'set:html': html });
					return contentFragment;
				}
				Content[Symbol.for('astro.needsHeadRendering')] = true;

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, images, rawContent, url };
