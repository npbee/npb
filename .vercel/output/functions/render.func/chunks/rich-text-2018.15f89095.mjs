const id = "rich-text-2018.md";
						const collection = "blog";
						const slug = "rich-text-2018";
						const body = "\nIf you're building a web app that allows users to write free-form text in 2018,\nit's very likely that you'll come upon the need to present that text with\nvarious formatting options like **bold** or _italic_, so called [_rich text_](https://techterms.com/definition/richtext).\nIn fact, I'd wager to say that it's almost a requirement to have some kind of\nrich text editing interface for any kind of business-user-facing web app because\nit's such a universally needed feature.\n\nDealing with rich text on the web is an interesting problem, but it's interesting\nbecause it's...well, uninteresting. Users have been inputting rich text for years\nin word processors like Microsoft Word, so the interaction details are somewhat known\nand established. There's not much in the way of exciting, modern UX to build here,\nso in that sense it's a little uninteresting. In that same sense, though, it's also\na _win_. Anytime you can build a web experience that users already know how to\nuse and lets them get stuff done is a good thing in my opinion.\n\nHowever, just because it's fairly established as a UX pattern doesn't mean it's\ncompletely solved as an implementation. It's been my personal mission the last\nfew weeks to solve this problem for an app we're building at [HelloSign](https://www.hellosign.com),\nso I've been deep in the weeds of this topic. During my research I found lots\nof good content on the surface-level implementation details, like which libraries\nare out there and the various techniques for building a rich text editor component.\nBut I found it difficult to find information on some of the deeper, more practical\nproblems that I was facing, like:\n\n- How do I store this in my database?\n- How do I handle both the editing _and_ displaying of the rich text in different contexts? Are those two concepts the same thing?\n- What about things like \"mentions\" that's not really just text?\n- What about security?\n\nSo I thought I'd write a bit about those particular aspects. This won't be an\narticle about the specifics of building a rich text editor, although I may add\none of those next!\n\n## What is rich text and why is it difficult?\n\nBefore going further it's probably best to give some context on what exactly I mean\nwhen referring to rich text. Here's a quick screen shot of a rich text editor\nfrom [Atlassian's component library](https://atlaskit.atlassian.com/examples/editor/editor-core/full-page):\n\n![Example of a rich text editor](/posts/rich-text.png)\n\nThe way I think about rich text is that it's plain text with additional structural\nand formatting information attached directly to it. I also think of rich text as\nhaving a few different vantage points:\n\n- From the perspective of the user, it's just text that's visually displayed with the chosen formatting (we'll get to things like \"mentions\" later).\n- From the perspective of the browser, it's HTML. This may seem obvious, but I find it helpful to call it out in order to distinguish this point of view from the next one.\n- From the perspective of the developer, it's data. Ultimately, rich text cannot be represented with just text, so it needs to be represented as some\n  sort of data structure. This _could_ also be HTML but it could also be another format, like JSON or markdown. More on that later.\n\nHaving these three perspectives helped me work towards a solution that fit my\nneeds but it also highlights why this problem can be a difficult one to solve. Like most\nproblems in web development, I found that there was really no one \"correct\"\nsolution. Each piece of the solution relied on various aspects of my own\nparticular needs. Trade offs were made.\n\nFor me, I found a few of the core considerations for the problem to be:\n\n- What kind of content will users be allowed to enter?\n- What are all of the rendering contexts that need to be supported?\n- How will security be handled?\n- What other processes need to interact with the rich text content?\n\nContinuing to ask these core questions along the way in my research helped me\nwork towards a reasonable (_I hope_ ðŸ˜¬) solution.\n\n## Database storage\n\nBefore moving forward with much else, I wanted to have an idea of the kinds of\ninputs and outputs I'd be dealing with and how I'd store and retrieve those\nvalues from the database. There were a few options that I'd found being used\nin the community.\n\n### HTML\n\nMost WYSIWYG (_what-you-see-is-what-you-get_) editors of the past worked strictly with\nHTML. Meaning, you start with a blob of HTML and you get out a blob of HTML.\nAn example would be an editor like [TinyMCE](https://www.tinymce.com/) or [CKEditor](https://ckeditor.com/).\nThis makes plenty of sense and existing libraries still do this today. After all,\nHTML is the language of the web. It's a standardized, familiar syntax that's\neasily interoperable with anything that can understand HTML.\n\nStoring the rich text value as HTML would mean storing a text value like this:\n\n```html\n<p>Open the console to see the <em>html.get</em> method working.</p>\n<p><span style=\"font-size: 18px;\">HELLO</span></p>\n<p>\n  <span style=\"font-size: 18px;\"\n    ><a href=\"https://google.com\">GOOGLE LINK</a></span\n  >\n</p>\n<p><br /></p>\n```\n\nIf you're at all security-minded, storing user-generated HTML probably sets\noff some red flags. Anytime you are storing user-generated content with the intent\nof rendering that content back out on the screen, you are vulnerable to [XSS](<https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)>) (Cross-site-scripting)\nattacks. Technically while any user-generated content is vulnerable to this, I\nfeel it's particularly relevant when dealing with rich text stored as HTML because\nit's likely that it will be rendered back out _as_ HTML (e.g. `element.innerHTML = storedHTML`) which is where XSS usually\ncomes in to play.\n\nThat said, storing HTML is perfectly valid and is still used today. There is a way to handle it that's\nreasonable safe. A general strategy could be to sanitize the generated HTML for XSS concerns\nand use a whitelist approached to strip out anything that you deem not appropriate.\nThere are plenty of libraries that do this ([DOMPurify](https://github.com/cure53/DOMPurify) is one).\nAnd note that you usually want to do this on _both_ inputs and outputs, so sanitize\non the server before saving to the database and before rendering to the screen. This will give you a\nreasonably safe implementation, but some security devs may still not love it.\nStoring HTML in the database can feel a bit like a ticking time bomb that can blow\nup some point way in the future if you forget to follow one of the security steps\nwhen saving or rendering.\n\nA few interesting points I noticed about using HTML to store rich text values:\n\n**It's very powerful for styling options**\n\nThis can be seen as either a good thing or bad thing. In the example above, to\nbe able to display a custom font size the `font-size` property is added:\n\n```html\n<span style=\"font-size: 18px\">words</span>\n```\n\nThis gives the client a pretty powerful mechanism for generating the exact\nvisual representation that it wants without much room for interpretation. This\ncould be a good thing if you need users to be able to expressive lots of\ndifferent visual formatting and you just want to retrieve this value from the\ndatabase and drop into an HTML page. However, there could be a case to be made\nthat it's _too_ powerful. The client could generate this:\n\n```html\n<span style=\"font-size: 3000px\">words</span>\n```\n\nIt's unlikely clients need the power to render font sizes at 3000 pixels!\n\n**It's a more literal representation of the contents**\n\nThe HTML generated in the example above is a very literal representation of the\ncontents. Meaning, it represents text with _exactly_ a font size of 18 pixels.\nIf you're only rendering within the context of web browsers and you want to be able to\nstick the generated content on a page and be done with it, this can be a good\noption. However I find that in some cases it can be better to leave yourself\nwith room to evolve your UI. For example, instead of saving a literal font size\nvalue maybe you save something like this:\n\n```html\n<span class=\"f-1\">words</span>\n```\n\nIn most cases, that's probably not what you want. Sure you can validate this\non both the client and the server, but it may become difficult to keep up with\nall of the different ways HTML can make for some horrible looking web pages.\n\nSimilar to how you might style a regular webpage, you likely don't style with\nexact pixel values but instead style with classes that represent relative values\nthat you can evolve and change over time. It also could allow you to represent\nthat text differently for different rendering contexts if you need to. For example,\nmaybe you're rendering to a PDF that uses a different font family so the pixel\nvalue needs to be slightly different.\n\nExploring the idea of storing my rich text as HTML began to highlight the fact that\nthere is a difference between storing the literal content of the rich text and\nstoring a _description_ of the rich text. For my use case, I wanted pretty tight\ncontrol over how my rich text rendered and even had different eventual rendering\ntargets (more on that later), so I realized that if I were to use HTML I would\nessentially be using HTML as a data format. Meaning, I likely wouldn't allow\njust _any_ HTML to be stored, it would be a controlled subset with a specific\nstructure that I could potentially render in different ways to different targets.\nIn fact, there's a good article by one of the project leads for CKEditor that\ndescribes using HTML as the data format for rich text: [A Standard for Rich-Text Data](https://medium.com/content-uneditable/a-standard-for-rich-text-data-4b3a507af552).\n\n### Markdown\n\nTo take a step back from HTML, my first thought for an MVP-like solution to this problem was to support [Markdown](https://daringfireball.net/projects/markdown/syntax).\nMarkdown is a fairly well-known syntax for doing basic formatting. It's used on\ndeveloper-centric sites like Github and StackOverflow. Markdown is a nice solution\nbecause it avoids a few of the security issues (but not all!) with HTML and doesn't require any\nkind of special client-side components to work with. It's still plain text when\nit's entered by the user and only turned into HTML when saved to the database or\nrendered to the browser. The syntax is small and relatively standardized so it's\nlikely there will be plenty of existing libraries to choose from that can take\nMarkdown and spit out HTML.\n\nThe issue with Markdown is that, by design, only supports a very limited set of\nformatting. If you're just doing bold and italic formatting, then Markdown will\nwork just fine. If you're doing anything more complex, like colors or font families,\nthen vanilla Markdown won't help you. There are some extensions and \"flavors\" to\nMarkdown for extending the syntax, but at that point I think Markdown starts to\nlose a little bit of its original value. Markdown is not really meant to do\nmuch more than basic formatting. Anything outside of basic formatting and Markdown\nyields to just allowing arbitrary HTML, in which case you're back to dealing\nwith all of the points mentioned in the above section.\n\nI like the idea of Markdown and I think it makes sense if you're able to stick with\nbasic formatting.\n\n### JSON\n\nIf you've decided that you want to store a description of your rich text data to\nyour database, JSON seems like a natural choice. In fact, many modern rich text\neditors represent their contents not with HTML but with a custom data structure\nthat can be easily serialized to JSON. QuillJS has a [Delta](https://quilljs.com/docs/delta/)\nformat, ProseMirror has a [Document](https://prosemirror.net/docs/ref/#model.Document_Structure),\nand DraftJS has its own [EditorState](https://draftjs.org/docs/api-reference-editor-state.html).\n\nBased on what we've discussed so far, here are some good things about storing rich\ntext as JSON:\n\n- It's more secure against XSS by default. You can't just pass a string of JSON\n  and render it as HTML.\n- It can represent any kind of content and formatting you might need\n- It can be easily parsed, validated, and manipluated by almost any system\n- It's a description of the content, so it can be rendered differently to different targets\n\nThose good things also come with some downsides:\n\n- No standardization. There is no _one_ JSON format for rich text. Each library\n  implements their own version which can lead to lock-in\n- More code. Because you can't just render JSON to HTML, that means you need to\n  write code that knows how to do that.\n\nJSON can be a good option for any reasonably complex rich text editor needs if you're\nwilling to write more code. A way of dealing with library and JSON format\nlock-in is to make sure you a strategy for migrating and making changes over time.\nUsing a [JSON Schema](http://json-schema.org/) definition with a version number\nis a good way to do that.\n\nThere are also explorations into standard-ish formats for representing rich text.\n[Mobiledoc](https://github.com/bustle/mobiledoc-kit) and [Portable Text](https://github.com/portabletext/portabletext) are two that I've seen in this area.\n\n## Rendering outside of the editor\n\nAnother interesting consideration when thinking about rich text is where you're\ngoing to need to render that rich text. In some cases, you only need it in the\ncontext of an editor. Something like Dropbox Paper or Google docs is an example.\nYou only ever pull that rich text up in the editor so you can be free to optimize\nfor that rendering target. But in some cases you have both the editing context\n_and_ the rendering context. For example, you may be editing rich text in the\nadmin section of a blog, saving it to the database, and then rendering it back\nout on a completely separate page. In those cases, you need a way to render that\nrich text to the screen directly from the database. HTML has an advantage here\nbecause it can just be rendered directly. JSON must be encoded to HTML somehow\nfirst. Some solutions to this require that a read-only instance of a rich text\neditor be loaded up to render the custom JSON format. I've found most rich text\nlibraries to be pretty heavy so in my opinion this is not ideal. However, a\nJSON format that is simple enough can be fairly easily encoded into HTML without\nthe need for the entire editor library. This also can help negate some of the\nsecurity issues with rendering user-generated content. A controlled \"renderer\"\nwill only render the things it knows about and likely will be rendering actual\nuser content as text, not HTML.\n\n## Summary\n\nThere's probably a lot more I could say about rich text.\nI found it to be a deep, challenging, and, at times, overwhelming topic for a seemingly universal need for most web apps.\nFor my own use, I ended up going with [ProseMirror](https://prosemirror.net/) but it's not without its own tradeoffs.\n\n## Thanks\n\nBig thanks to Atlassian for their open-source code in [AtlasKit](https://atlaskit.atlassian.com/) which was a great help in seeing how a real-world rich text eidtor could be built.\n";
						const data = {title:"Rich Text on the Web in 2018",date:new Date(1530662400000),description:"Thoughts on building a rich text editor"};
						const _internal = {
							type: 'content',
							filePath: "/Users/nickball/code/npb/src/content/blog/rich-text-2018.md",
							rawData: "\ntitle: Rich Text on the Web in 2018\ndate: 2018-07-04\ndescription: Thoughts on building a rich text editor",
						};

export { _internal, body, collection, data, id, slug };
